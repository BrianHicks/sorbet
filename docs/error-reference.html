<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Sorbet Error Reference · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;style&gt;"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Sorbet Error Reference · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="&lt;style&gt;"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Troubleshooting</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">Type Assertions</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow Sensitivity</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">Type Aliases</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/error-reference.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Sorbet Error Reference</h1></header><article><div><span><style>
#missing-doc-for-error-code-box.is-hidden {
  display: none;
}
</style>
<div class="is-hidden red" id="missing-doc-for-error-code-box">
<p><a class="anchor" aria-hidden="true" id="missing-doc-for-error-code-scroll"></a></p>
<blockquote>
<p><strong>Heads up</strong>: There aren’t any docs yet for <span id="missing-error-code">this
error code</span>. If you have suggestions for what would have helped you
solve this problem, click the “Edit” button above to contribute! Otherwise,
try using the search above to find an answer.</p>
</blockquote>
</div>
<blockquote>
<p><strong>Note</strong>: This list is not exhaustive! Some errors are very context dependent
and other error codes are not common enough to know how to generally suggest
help. Contributions to this list are welcome!</p>
</blockquote>
<p>This is one of three docs aimed at helping answer common questions about Sorbet:</p>
<ol>
<li><a href="/docs/troubleshooting">Troubleshooting</a></li>
<li><a href="/docs/faq">Frequently Asked Questions</a></li>
<li><a href="/docs/error-reference">Sorbet Error Reference</a> (this doc)</li>
</ol>
<p>This page contains tips and tricks for common errors from <code>srb</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="1001"></a><a href="#1001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1001</h2>
<p>Sorbet has crashed. Please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a>!</p>
<h2><a class="anchor" aria-hidden="true" id="1003"></a><a href="#1003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1003</h2>
<p>Sorbet has an internal limitation on how deep a chain of class aliases can be:</p>
<pre><code class="hljs css language-ruby">A1 = Integer
A2 = A1
<span class="hljs-comment"># ...</span>
A42 = A41
A43 = A42 <span class="hljs-comment"># error: Too many alias expansions</span>
</code></pre>
<p>It’s meant to guard against cases where Sorbet might get stuck in an infinite
loop attempting to dealias these class aliases.</p>
<p>If you encounter this bug in the wild (i.e., not just for a contrived example,
but a real-world use case), please share with the Sorbet team. We’d like to see
what mode of use triggered this behavior, and either add a test to Sorbet or
tweak how Sorbet works to support the use case.</p>
<h2><a class="anchor" aria-hidden="true" id="1004"></a><a href="#1004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1004</h2>
<p>Sorbet couldn’t find a file.</p>
<h2><a class="anchor" aria-hidden="true" id="2001"></a><a href="#2001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2001</h2>
<p>There was a Ruby syntax error. Sorbet was unable to parse the source code. If
you encounter this error but your code is accepted by Ruby itself, this is a bug
in our parser; please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a> to us so we can address it.</p>
<p>The only intentional break with Ruby compatibility is that method names that are
keywords have some limitations with multi-line code, as explained in <a href="https://github.com/sorbet/sorbet/pull/1993">#1993</a>,
and should not be reported.</p>
<h2><a class="anchor" aria-hidden="true" id="2003"></a><a href="#2003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2003</h2>
<p>If you’re seeing this error code, it means that Sorbet already emitted a parse
error for the file, but found some extra information that might help point out
the root cause of a syntax error. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-keyword">if</span> x
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This Ruby snippet does not parse, but the reason why is confusing. Because Ruby
does not care about indentation, it will try to consune <code>end</code> keywords eagerly
if there is something available to match. In this example, the first <code>end</code>
matches with <code>if</code> and the second matches with <code>def</code> and so Sorbet will report
<code>unexpected token &quot;end of file&quot;</code> because the <code>class A</code> definition was not
matched with an <code>end</code> token.</p>
<p>But given the indentation structure present in the original program, it’s more
likely that the <code>if x</code> statement is unclosed. Thus, in some cases, Sorbet will
provide extra “Hint:” diagnostics that point out things that might be the root
cause.</p>
<p>It’s important to note that <strong>these hints are imperfect</strong>—fixing them might not
actually fix the real parse error. Instead, they’re provided as a way to help
recover from the real parse error.</p>
<p>As with all Sorbet error messages, if one of these hint error messages is
confusing or misleading, please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a> to let us know.</p>
<h2><a class="anchor" aria-hidden="true" id="3001"></a><a href="#3001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3001</h2>
<p>Sorbet doesn’t support singleton definitions outside of the class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; MyClass <span class="hljs-comment"># error: `class &lt;&lt; EXPRESSION` is only supported for `class &lt;&lt; self`</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The workaround is to move the definition inside the <code>MyClass</code> class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      <span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, <code>EXPRESSION</code> is not a constant literal like in what follows:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; some_variable</span>
  <span class="hljs-keyword">include</span> Foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, it is possible to directly call <code>include</code> on the the singleton
class of <code>EXPRESSION</code>, but it should be done with <strong>utmost caution</strong>, as Sorbet
will not consider the include and provide a less accurate analysis (see also
<a href="#4002">#4002</a>):</p>
<pre><code class="hljs css language-rb">some_variable.singleton_class.<span class="hljs-keyword">include</span>(Foo)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3002"></a><a href="#3002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3002</h2>
<p>Sorbet is limited to C++ <code>INT_MAX</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-number">11377327221391349843</span> + <span class="hljs-number">1</span> <span class="hljs-comment"># error: Unsupported integer literal: 11377327221391349843</span>
</code></pre>
<p>A possible workaround is to use a string and <code>to_i</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-string">"11377327221391349843"</span>.to_i + <span class="hljs-number">1</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3011"></a><a href="#3011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3011</h2>
<p>There was a Hash literal with duplicated keys.</p>
<pre><code class="hljs css language-ruby">{<span class="hljs-symbol">my_key:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">my_key:</span> <span class="hljs-number">2</span>} <span class="hljs-comment"># error: `my_key` is duplicated</span>
</code></pre>
<p>This error can also be caused when trying to write a <code>sig</code> for a method with
duplicated parameter names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_:</span> String, <span class="hljs-symbol">_:</span> Integer).void} <span class="hljs-comment"># error: `_` is duplicated</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">_</span>, <span class="hljs-number">_</span>)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<p>To write a <code>sig</code> for this method, rename the method’s parameters to have unique
names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_a:</span> String, <span class="hljs-symbol">_b:</span> Integer).void} <span class="hljs-comment"># ok</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(_a, _b)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4001"></a><a href="#4001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4001</h2>
<p>Sorbet parses the syntax of <code>include</code> and <code>extend</code> declarations, even in
<code># typed: false</code> files. Recall from the
<a href="/docs/static#file-level-granularity-strictness-levels">strictness levels</a> docs
that all constants in a Sorbet codebase must resolve, even at <code># typed: false</code>.
Parsing <code>include</code> blocks is required for this, so incorrect usages of <code>include</code>
are reported when encountered.</p>
<h2><a class="anchor" aria-hidden="true" id="4002"></a><a href="#4002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4002</h2>
<p>Sorbet requires that every <code>include</code> references a constant literal. For example,
this is an error, even in <code># typed: false</code> files:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> x  <span class="hljs-comment"># error: `include` must be passed a constant literal</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Non-constant literals make it hard to impossible to determine the complete
inheritance hierarchy in a codebase. Sorbet must know the complete inheritance
hierarchy of a codebase in order to check that a variable is a valid instance of
a type.</p>
<p>It is possible to silence this error with <code>T.unsafe</code>, but it should be done with
<strong>utmost caution</strong>, as Sorbet will not consider the include and provide a less
accurate analysis:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  T.unsafe(<span class="hljs-keyword">self</span>).<span class="hljs-keyword">include</span> x
<span class="hljs-keyword">end</span>
</code></pre>
<p>Which might create unexpected errors:</p>
<pre><code class="hljs css language-ruby">c = C.new

c.a <span class="hljs-comment"># error: Method `a` does not exist on `C`</span>
c.b <span class="hljs-comment"># error: Method `b` does not exist on `C`</span>

T.let(C, A) <span class="hljs-comment"># error: Argument does not have asserted type `A`</span>
T.let(C, B) <span class="hljs-comment"># error: Argument does not have asserted type `B`</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4003"></a><a href="#4003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4003</h2>
<p>Sorbet parses the syntax of <code>include</code> and <code>extend</code> declarations, even in
<code># typed: false</code> files. Recall from the
<a href="/docs/static#file-level-granularity-strictness-levels">strictness levels</a> docs
that all constants in a Sorbet codebase must resolve, even at <code># typed: false</code>.
Parsing <code>include</code> blocks is required for this, so incorrect usages of <code>include</code>
are reported when encountered.</p>
<h2><a class="anchor" aria-hidden="true" id="4006"></a><a href="#4006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4006</h2>
<p>The <code>super</code> keyword in Ruby will call the method with the same name on the
nearest ancestor (whether on a mixed-in module or the superclass).</p>
<p>This method only makes sense to call inside the body of a method, not inside a
class or file top-level.</p>
<h2><a class="anchor" aria-hidden="true" id="4010"></a><a href="#4010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4010</h2>
<p>When using Sorbet, try to avoid redefining a method. A method is redefined when
a method of the same name is defined in the same class (note that Sorbet
completely supports overriding methods, where two methods have the same name but
one is in a parent class and one in a child class).</p>
<p>If redefining a method is unavoidable, the arity of the new method must match
the previous method’s arity exactly. A method’s arity includes how many
positional arguments a method has, which keyword arguments it takes, etc.</p>
<p>Determining the arity of the previous method can sometimes be tricky, especially
when the previous method was defined dynamically by a DSL. In these cases, the
easiest way to determine a method’s arity is to find a place where that method
is <strong>called</strong>, hover over it using Sorbet’s <a href="/docs/vscode">editor integration</a>, and
copy the displayed method definition.</p>
<p>It’s worth noting that this error occurs particularly frequently in RBI files,
especially autogenerated RBI files. Consider a case like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- some_gem.rbi --</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeGem</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x = <span class="hljs-literal">nil</span>, y = <span class="hljs-literal">nil</span>)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- autogenerated/some_gem.rbi --</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeGem</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, two RBIs define conflicting definitions for <code>SomeGem#foo</code> because
the arity of <code>x, y</code> does not match the arity of <code>*args</code>. (This frequently
happens because, say, the gem wants to do custom parameter checking so that in
certain cases <code>x</code> or <code>y</code> is actually required.) The <code>autogenerated/</code> RBI file
was generated by using Ruby’s reflection APIs to ask for the arity of the method
as seen by the Ruby VM, while the other RBI was hand-written by the gem
maintainer.</p>
<p>In cases like these, usually the solution is to remove the <code>foo</code> definition from
<code>autogenerated/some_gem.rbi</code>, which can usually be accomplished by regenerating
the RBI.</p>
<p><strong>Note</strong>: The arity of a method does not include types, only names and kinds of
its parameters. For example:</p>
<pre><code class="hljs css language-ruby">sig {returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
sig {returns(String)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, both <code>foo</code> methods have the same arity (they take no arguments,
or are “nullary”), so no error is raised about redefining a method.</p>
<p>But in this case, where their signatures specify different types, the behavior
is unspecified. Sorbet <strong>usually</strong> takes the types from the “last” signature,
but which signature is “last” is implementation defined when when the two method
definitions happen in two separate files. This includes the case when both a
Ruby source file (<code>*.rb</code>) and an RBI file (<code>*.rbi</code>) specify a signature for a
method.</p>
<p>That Sorbet supports method redefinitions, including providing multiple
signatures for a method definition across multiple files, and that this error is
<strong>only</strong> reported at <code># typed: true</code> and above is an accident of history, and
part of the reason why Sorbet strongly discourages using method redefinitions.</p>
<p>One alternative is to mark the original method <code>private</code> and define a new method
with a new name, instead of redefining the old method. Another alternative is to
use Sorbet’s <a href="/docs/vscode">editor integration</a> to rename the old method, declare
that old method <code>private</code>, and define a new method with the original name.</p>
<h2><a class="anchor" aria-hidden="true" id="4011"></a><a href="#4011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4011</h2>
<p>There are multiple definitions for the same type member within a given class or
module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member
  Elem = type_member <span class="hljs-comment"># error: Duplicate type member</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>You can fix this by removing the second definition of the type member:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4012"></a><a href="#4012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4012</h2>
<p>A <code>class</code> was redefined as a <code>module</code> or <em>vice versa</em> in two separate locations.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># file_a.rb</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># file_b.rb</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0A%23%20file_a.rb%0Aclass%20Foo%0Aend%0A%0A%23%20file_b.rb%0Amodule%20Foo%0Aend">→
View on sorbet.run</a></p>
<p>You can fix this error by ensuring that both definitions are declared as
<code>class</code>es, ensuring both definitions are declared as <code>module</code>s, or renaming
either definition so they no longer conflict.</p>
<h2><a class="anchor" aria-hidden="true" id="4013"></a><a href="#4013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4013</h2>
<p>The <code>interface!</code> annotation is reserved for modules. To include abstract methods
in a class, mark the class <code>abstract!</code> instead.</p>
<h2><a class="anchor" aria-hidden="true" id="4014"></a><a href="#4014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4014</h2>
<p>Sorbet does not support dynamic constant references. All constants must be plain
constant literals.</p>
<p>If you are adopting Sorbet in your codebase and get stuck dealing with how to
avoid using a particular dynamic constant reference, you might want to ask
someone in <a href="/en/community">the Sorbet community</a> whether they have encountered
the problem before. Members of the Sorbet community frequently answer questions
either on Slack or Stack Overflow.</p>
<p><strong>Why is it this way?</strong> Sorbet has a simple architecture which has been chosen
to optimize for performance in large codebases. Specifically, Sorbet only knows
which method is being called during its inference phase. The inference phase
requires that a complete symbol table (listing all classes, all the methods that
class owns, and all the methods’ types) has been built already. Thus building
this symbol table cannot depend on knowing which methods are defined.</p>
<p>This is also a philosophical belief that Ruby codebases are easier for
programmers to understand when constant references are simple.</p>
<h2><a class="anchor" aria-hidden="true" id="4015"></a><a href="#4015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4015</h2>
<p>This error usually comes when a class or module is dynamically defined and
stored into a constant, like this:</p>
<pre><code class="hljs css language-ruby">A = ...
A::B = <span class="hljs-number">1</span>
</code></pre>
<p>where <code>...</code> is some expression which computes a class or module. Sorbet can’t
know statically what this <code>...</code> code does (and for example even if could assume
that it’s defining a class, Sorbet can’t know what methods or constants it has).
Therefore, Sorbet does not support this pattern.</p>
<h2><a class="anchor" aria-hidden="true" id="4016"></a><a href="#4016" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4016</h2>
<p><code>type_member</code> and <code>type_template</code> cannot be used at the top-level of a file.
Instead, they must be used inside a class or module definition.</p>
<h2><a class="anchor" aria-hidden="true" id="4019"></a><a href="#4019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4019</h2>
<p>This error is only reported when running Sorbet with the <code>--stripe-mode</code> command
line flag.</p>
<p>A class defines behavior in multiple files when at least two files would need to
be run in order to completely load that class. A class definition that only
serves as a namespace for inner definitions is not considered to have behavior.
For example, in this example module <code>A</code> has behavior in two files:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- file1.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- file2.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>However, in this example, module <code>A</code> does not have any behavior:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- file1.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A::B</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- file2.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A::B</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The limitations around what constitutes “defining behavior” is intertwined with
which files would have to be loaded for a class (like <code>A</code> above) to be fully
loaded. In <code>--stripe-mode</code>, there must be at most one file to require to fully
load a class.</p>
<h2><a class="anchor" aria-hidden="true" id="4021"></a><a href="#4021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4021</h2>
<p>The syntax for specifying type bounds when using <code>type_member</code> and
<code>type_template</code> has changed. The old syntax looked used a method call with
keyword args:</p>
<pre><code class="hljs css language-ruby">type_member(<span class="hljs-symbol">fixed:</span> ...)
</code></pre>
<p>while the new syntax uses a block that returns a <code>Hash</code> literal:</p>
<pre><code class="hljs css language-ruby">type_member {{<span class="hljs-symbol">fixed:</span> ...}}
</code></pre>
<p>(Note that any variance annotation like <code>:in</code> or <code>:out</code> is still specified as
the first positional argument.)</p>
<p>This new syntax mimics the syntax for <code>T.type_alias</code>, and shares the same
motivation: generics in Sorbet are completely erased at runtime, so it’s silly
to have to pay the runtime price of computing the runtime types passed to
<code>:fixed</code>, <code>:upper</code>, and <code>:lower</code>. In codebases that heavily autoload constants,
it’s also easy for <code>type_member</code> definitions to cause constants to be loaded
earlier than they might have been otherwise (potentially introducing load-time
cyclic references).</p>
<p>The first version of Sorbet on RubyGems to support the new syntax is 0.5.9889.
It accepts both syntaxes side by side, so you can use it while incrementally
migrating your codebase to the new syntax.</p>
<p>This error includes an autocorrect you can run to automatically migrate to the
new syntax:</p>
<pre><code class="hljs">srb tc --isolate-error-code=<span class="hljs-number">4021</span> --<span class="hljs-built_in">auto</span>correct
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5001"></a><a href="#5001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5001</h2>
<p>Sorbet cannot resolve references to dynamic constants. The common case occurs
when a constant is dynamically referenced through the singleton class of <code>self</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  CACHE_KEY_PREFIX = <span class="hljs-string">"my_cachable_"</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>::<span class="hljs-title">CACHE_KEY_PREFIX</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This code can by made statically analysable by using a singleton method to
reference the constant:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">cache_key_prefix</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key_prefix</span></span>
      <span class="hljs-string">"my_cachable_"</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5002"></a><a href="#5002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5002</h2>
<p>This means that the typechecker has been unable to resolve a reference to a
constant (e.g., a Ruby class). Most commonly, this indicates that there’s a
typo.</p>
<p>First, try confirming whether the code runs successfully. Does the code raise an
“uninitialized constant” error when run? If so, Sorbet caught a bug! Try finding
out why that constant is actually uninitialized.</p>
<p>If it isn’t a typo, then there are a few other things to look at. If it looks
like the constant is related to a gem, maybe one of these helps:</p>
<ul>
<li><p>Is it coming from a gem? Sorbet does not look through the gem’s source code.
Instead, there must be an <code>*.rbi</code> file for this gem. Try finding the <code>*.rbi</code>
corresponding to this gem, and searching through it for the constant.</p>
<p>For more information, see <a href="/docs/rbi">RBI files</a>. If you are at Stripe, please
instead see <a href="http://go/types/rbi">http://go/types/rbi</a>.</p></li>
<li><p>If the gem was recently updated, its <code>*.rbi</code> might need to be regenerated.
Each RBI file has a line at the top which can be copy / pasted to re-generate
the file when the underlying gem has changed.</p></li>
<li><p>When deleting constants, sometimes they are still referenced from an
autogenerated <code>*.rbi</code> file. If that’s the case, consider deleting the constant
or regenerating the file.</p></li>
</ul>
<p>Another thing it could be: Sorbet explicitly does not support resolving
constants through ancestors (both mixins or superclasses).</p>
<p>Concretely, here’s an example of code rejected and accepted by Sorbet:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent;</span> <span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># error</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<p>Alternatively, if it’s much more preferable to access the constant on the child,
we can set up an explicit alias:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  MY_CONST = Parent::MY_CONST
<span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># ok</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5005"></a><a href="#5005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5005</h2>
<p>A class or instance variable is defined in the wrong context.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @@class_var = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-number">10</span>, Integer)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>There are two such errors in the above. In the first, <code>@@class_var</code> is declared
outside of the class scope. In the second, <code>@x</code> is declared outside of the
<code>initialize</code> method.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5006"></a><a href="#5006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5006</h2>
<p>An instance variable has been redeclared with another type.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-string">"x"</span>, String)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5008"></a><a href="#5008" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5008</h2>
<p>A class was defined as the subclass of a <code>type_alias</code>. It also occurs if a
<code>type_alias</code> mixin is used in a class.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
A = T.type_alias {Integer}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; A;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span>;</span> <span class="hljs-keyword">end</span>

AliasModule = T.type_alias {M}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> AliasModule <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5011"></a><a href="#5011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5011</h2>
<p>A class inherits from itself either directly or through an inheritance chain.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt; A;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; C;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5012"></a><a href="#5012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5012</h2>
<p>A class was changed to inherit from a different superclass.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; A;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5013"></a><a href="#5013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5013</h2>
<p>A class or instance variable declaration used <code>T.cast</code> when it should use
<code>T.let</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  @@x = T.cast(<span class="hljs-number">10</span>, Integer)
<span class="hljs-keyword">end</span>
</code></pre>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>To instead use <code>T.cast</code> as a runtime-only type check (that is, neither as a
statically-checked assertion nor as an instance variable declaration), assign
the cast result to an intermediate variable:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  x = T.cast(<span class="hljs-number">10</span>, Integer)
  @@x = x
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5014"></a><a href="#5014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5014</h2>
<p>Given code like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
<span class="hljs-keyword">end</span>
</code></pre>
<p>We need to change our code to redeclare the type member in the child class too:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>
</code></pre>
<p>The same thing holds for type templates.</p>
<h2><a class="anchor" aria-hidden="true" id="5023"></a><a href="#5023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5023</h2>
<p>Some modules require specific functionality in the receiving class to work. For
example <code>Enumerable</code> needs a <code>each</code> method in the target class.</p>
<p>Failing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>
<span class="hljs-symbol">end</span>
</code></pre>
<p>To fix this, implement the required abstract methods in your class to provide
the required functionality.</p>
<p>Passing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0A%0A%20%20def%20each(%2526blk)%0A%0A%20%20end%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>

  <span class="hljs-symbol">def</span> <span class="hljs-symbol">each</span>(&amp;<span class="hljs-symbol">blk</span>)
  <span class="hljs-symbol">end</span>
<span class="hljs-symbol">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5028"></a><a href="#5028" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5028</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all constants are annotated
with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#6002">6002</a>, <a href="#7017">7017</a>, <a href="#7027">7027</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5034"></a><a href="#5034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5034</h2>
<p>Sorbet does not support creating normal Ruby constant aliases to type aliases.
Once a type alias is created, all subsequent aliases must also be type aliases.</p>
<p>Concretely, this is not allowed:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = A <span class="hljs-comment"># error: Reassigning a type alias is not allowed</span>
</code></pre>
<p>while this is:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = T.type_alias {A}
</code></pre>
<p>(Why? This is due to design tradeoffs to enforce stronger internal invariants.
Basically, Sorbet can emit more reliable warnings when users declare their
intent to create a new type alias.)</p>
<h2><a class="anchor" aria-hidden="true" id="5035"></a><a href="#5035" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5035</h2>
<p>A method was marked <code>override</code>, but sorbet was unable to find a method in the
class’s ancestors that would be overridden. Ensure that the method being
overridden exists in the ancestors of the class defining the <code>override</code> method,
or remove <code>override</code> from the signature that’s raising the error. See
<a href="override-checking">Override Checking</a> for more information about <code>override</code>.</p>
<p>If the parent method definitely exists at runtime, it might be hidden in a
<a href="static#file-level-granularity-strictness-levels"><code># typed: ignore</code></a> file.
Sorbet will not see it and this error will be raised. In that case you will need
to either raise the <code>typed</code> sigil of that file above <code>ignore</code>, or generate an
<a href="rbi">RBI file</a> that contains signatures for the classes and methods that file
defines.</p>
<h2><a class="anchor" aria-hidden="true" id="5036"></a><a href="#5036" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5036</h2>
<p>See <a href="#5014">5014</a>. 5036 is the same error as <a href="#5014">5014</a> but slightly modified
to allow more common Ruby idioms to pass by in <code># typed: true</code> (5036 is only
reported in <code># typed: strict</code>).</p>
<h2><a class="anchor" aria-hidden="true" id="5037"></a><a href="#5037" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5037</h2>
<p>Sorbet must be able to statically resolve a method to create an alias to it.</p>
<p>Here, the method is created through a DSL called <code>data_accessor</code> which defines
methods at runtime through meta-programming:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">data_accessor</span><span class="hljs-params">(key)</span></span>
    define_method(key) <span class="hljs-keyword">do</span>
      data[key]
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt; Base</span>
  data_accessor <span class="hljs-symbol">:foo</span>

  alias_method <span class="hljs-symbol">:bar</span>, <span class="hljs-symbol">:foo</span> <span class="hljs-comment"># error: Can't make method alias from `bar` to non existing method `foo`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>One way to make those methods visible statically is to add a declaration for
them in an <a href="https://sorbet.org/docs/rbi">RBI file</a>. For example, we can write
our definitions as RBI under <code>sorbet/rbi/shims/foo.rbi</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-comment"># sorbet/rbi/shims/foo.rbi</span>
<span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, Sorbet will complain about an alias to a method coming from an
included modules. For example, here <code>bar</code> is coming from the inclusion of <code>Bar</code>
but Sorbet will complain about the method not existing anyway:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  alias_method <span class="hljs-symbol">:foo</span>, <span class="hljs-symbol">:bar</span> <span class="hljs-comment"># error: Can't make method alias from `foo` to non existing method `bar`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s because Sorbet resolves method aliases before it resolves includes. You can
see an example of this behaviour
<a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Bar%0A%20%20def%20bar%3B%20end%0Aend%0A%0Amodule%20Foo%0A%20%20include%20Bar%0A%0A%20%20alias_method%20%3Afoo%2C%20%3Abar%20%23%20aliases%20are%20resolved%20before%20includes%2C%20so%20%60bar%60%20is%20not%20found%20yet%0A%0A%20%20def%20baz%0A%20%20%20%20bar%20%23%20includes%20are%20resolved%20when%20we%20analyze%20this%20code%0A%20%20end%0Aend">here</a>.
To workaround this limitation, we can replace the <code>alias_method</code> by a real
method definition:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    bar
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5041"></a><a href="#5041" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5041</h2>
<p>Sorbet does not allow inheriting from a class which inherits from <code>T::Struct</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> &lt; S;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>
</code></pre>
<p>This limitation exists because, in order to generate a static type for
<code>initialize</code> for a struct, we need to know all of the <code>prop</code>s that are declared
on this struct. By disallowing inheritance of structs, we can know that all of
the props declared on this struct were syntactically present in the class body.</p>
<p>One common situation where inheritance may be desired is when a parent struct
declares some common props, and children structs declare their own props.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span> &lt; Parent <span class="hljs-comment"># error</span></span>
  prop <span class="hljs-symbol">:bar</span>, String
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span> &lt; Parent <span class="hljs-comment"># error</span></span>
  prop <span class="hljs-symbol">:quz</span>, Symbol
<span class="hljs-keyword">end</span>
</code></pre>
<p>We can restructure the code to use composition instead of inheritance.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Common</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:common</span>, Common
  prop <span class="hljs-symbol">:bar</span>, String
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:common</span>, Common
  prop <span class="hljs-symbol">:quz</span>, Symbol
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5046"></a><a href="#5046" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5046</h2>
<p>Generic classes must be passed all their generic type arguments when being used
as types. For example:</p>
<pre><code class="hljs css language-ruby">T.let([], Array)              <span class="hljs-comment"># error</span>
T.let([], T::Array[Integer])  <span class="hljs-comment"># ok</span>
</code></pre>
<p>Many classes in the standard library are generic classes
(<a href="/docs/stdlib-generics">see here</a>), and must be passed type arguments, including
<code>Array</code> and <code>Hash</code>. Any user-defined generic classes must similarly be provided
type arguments when used.</p>
<p>For legacy reasons relating to the intial rollout of Sorbet, this error is only
reported at <code># typed: strict</code> for standard library generic classes and
<code># typed: true</code> for all user-defined generic classes. (In an ideal world, it
would have always been reported at <code># typed: true</code>, and we might change this in
the future.)</p>
<h2><a class="anchor" aria-hidden="true" id="5047"></a><a href="#5047" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5047</h2>
<p>A class or module tried to inherit, include, or extend a final class or module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Final</span></span>
  extend T::Helpers
  final!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> &lt; Final;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5048"></a><a href="#5048" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5048</h2>
<p>A class or module was declared as final, but a method in the class or module was
not explicitly declared as final with a final <code>sig</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  extend T::Helpers
  final!

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">no_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  extend T::Sig

  sig {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">non_final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  sig(<span class="hljs-symbol">:final</span>) {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># good</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5054"></a><a href="#5054" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5054</h2>
<p>Use of <code>implementation</code> has been replaced by <code>override</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="5056"></a><a href="#5056" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5056</h2>
<p>The <code>generated</code> annotation in method signatures is deprecated.</p>
<p>For alternatives, see <a href="/docs/runtime">Enabling Runtime Checks</a> which talks about
how to change the runtime behavior when method signatures encounter a problem.</p>
<h2><a class="anchor" aria-hidden="true" id="5057"></a><a href="#5057" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5057</h2>
<p>Static methods (like <code>self.foo</code>) can never be mixed into another class or
module. Both <code>include</code> and <code>extend</code> only mix that module’s <em>instance</em> methods
onto the target class or module. Classes can inherit static methods from their
superclass, but only classes (not modules) can be superclasses.</p>
<p>Thus, a static, abstract method on a module is impossible to implement, and thus
is a no-op.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyMixin</span></span>
  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Static methods in a module cannot be abstract</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Some alternatives:</p>
<ul>
<li><p>Use <code>mixes_in_class_methods</code>, which declares to Sorbet that when a module is
included, some other module should be extended into the target class.
<a href="/docs/abstract">Full documentation here</a>. This is the preferred option.</p></li>
<li><p>Separate the interface into two modules. Include one and extend the other in
all the places where</p></li>
<li><p>Change the abstract module to an abstract class, and update all downstream
references to inherit from this class instead of including the original
module.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="5058"></a><a href="#5058" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5058</h2>
<p>It’s an error to use <code>T.attached_class</code> to describe the type of method
parameters. See the
<a href="/docs/attached-class#tattached_class-as-an-argument">T.attached_class</a>
documentation for a more thorough description of why this is.</p>
<h2><a class="anchor" aria-hidden="true" id="5064"></a><a href="#5064" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5064</h2>
<p>Using the <code>requires_ancestor</code> method, module <code>Bar</code> has indicated to Sorbet that
it can only work properly if it is explicitly included along module <code>Foo</code>. In
this example, we see that while module <code>Bar</code> is included in <code>MyClass</code>, <code>MyClass</code>
does not include <code>Foo</code>.</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  extend T::Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-comment"># error: `MyClass` must include `Foo` (required by `Bar`)</span></span>
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>The solution is to include <code>Foo</code> in <code>MyClass</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-keyword">include</span> Foo
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>Other potential (albeit less common) sources of this error code are classes that
are required to have some class as an ancestor:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  <span class="hljs-keyword">extend</span> <span class="hljs-symbol">T:</span>:Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span></span>
  <span class="hljs-keyword">extend</span> <span class="hljs-symbol">T:</span>:Helpers
  <span class="hljs-keyword">include</span> Bar

  <span class="hljs-keyword">abstract</span>!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; <span class="hljs-title">MySuperClass</span> <span class="hljs-comment"># error: `MyClass` must inherit `Foo` (required by `Bar`)</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Ensuring <code>MyClass</code> inherits from <code>Foo</code> at some point will fix the error:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span> &lt; Foo</span>
  extend T::Helpers
  <span class="hljs-keyword">include</span> Bar

  abstract!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; MySuperClass</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5068"></a><a href="#5068" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5068</h2>
<p>Sorbet requires that class or module definitions be namespaced unambiguously.
For example, in this code:</p>
<pre><code class="hljs"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The definition B::C is ambiguous. In Ruby’s runtime, it resolves to B::C (and
not A::B::C). However, things are different in the presence of a pre-declared
filler namespace like below:</p>
<pre><code class="hljs"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, the definition resolves to A::B::C in Ruby’s runtime.</p>
<p>By default, Sorbet assumes the presence of filler namespaces while typechecking,
regardless of whether they are explicitly predeclared like in the second
example. This means that in Sorbet’s view, the definition resolves to A::B::C in
either case.</p>
<p>In Stripe’s codebase, this is generally not a problem at runtime, as we use
Sorbet’s own autoloader generation to pre-declare filler namespaces, keeping the
Ruby runtime’s behavior equivalent to Sorbet. However, the autoloader has some
edge cases, which can often cause deviations between Ruby’s runtime and Sorbet.
This error helps guard against these issues.</p>
<h2><a class="anchor" aria-hidden="true" id="6001"></a><a href="#6001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6001</h2>
<p>Certain Ruby keywords like <code>break</code>, <code>next</code>, and <code>retry</code> can only be used inside
a Ruby block.</p>
<h2><a class="anchor" aria-hidden="true" id="6002"></a><a href="#6002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6002</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all instance and class
variables are annotated with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#7017">7017</a>, <a href="#7028">7028</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="6004"></a><a href="#6004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6004</h2>
<p>In order to statically check <a href="exhaustiveness">exhaustiveness</a>, Sorbet provides
<code>T.absurd</code>, which lets people opt into exhaustiveness checks.</p>
<p><code>T.absurd</code> must be given a variable. If not, like in this example, it reports an
error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- bad example --</span>

sig {returns(T.any(Integer, String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns_int_or_string</span>;</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">end</span>

<span class="hljs-keyword">case</span> returns_int_or_string
<span class="hljs-keyword">when</span> Integer <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got int'</span>
<span class="hljs-keyword">when</span> String <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got string'</span>
<span class="hljs-comment"># error! `returns_int_or_string` is not a variable!</span>
<span class="hljs-keyword">else</span> T.absurd(returns_int_or_string)
<span class="hljs-keyword">end</span>
</code></pre>
<p>While it looks like <code>returns_int_or_string</code> is the name of a variable, it’s
actually a method call (Ruby allows method calls to omit parentheses). To fix
this error, store the result of calling <code>returns_int_or_string</code> in a variable,
and use that variable with the <code>case</code> and <code>T.absurd</code>:</p>
<pre><code class="hljs css language-ruby">sig {returns(T.any(Integer, String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns_int_or_string</span>;</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">end</span>

<span class="hljs-comment"># calls returns_int_or_string, stores result in x</span>
x = returns_int_or_string

<span class="hljs-keyword">case</span> x
<span class="hljs-keyword">when</span> Integer <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got int'</span>
<span class="hljs-keyword">when</span> String <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got string'</span>
<span class="hljs-keyword">else</span> T.absurd(x)
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="6005"></a><a href="#6005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6005</h2>
<p><code>T.bind</code> can only be called on <code>self</code>, syntactically.</p>
<p>To perform type assertions on non-<code>self</code> things, use <code>T.let</code> or <code>T.cast</code>.</p>
<p>See <a href="/docs/type-assertions">Type Assertions</a> for more.</p>
<h2><a class="anchor" aria-hidden="true" id="7001"></a><a href="#7001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7001</h2>
<p>Sorbet does not allow reassigning a variable to a different type within a loop
or block. (Note that we model blocks similarly to loops, as in general they may
execute 0, 1, or more times). Due to implementation constraints, Sorbet does not
permit this behavior.</p>
<p>A prototypical example of code that might trigger this is code that sets a
variable to <code>nil</code>, and then updates it if some value is found inside a loop:</p>
<pre><code class="hljs css language-ruby">found = <span class="hljs-literal">nil</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p>In most cases, we can fix this error by declaring the type of the loop variable
outside the loop using <code>T.let</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># This is a type annotation that explicitly widens the type:</span>
found = T.let(<span class="hljs-literal">nil</span>, T.nilable(String))

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p><strong>But my variable does not change its type, it is always a <code>Boolean</code>!</strong></p>
<p>In Ruby, there is no <code>Boolean</code> type. Instead, there are <code>FalseClass</code> and
<code>TrueClass</code> types, the union of which defines
<a href="/docs/class-types#booleans"><code>T::Boolean</code> type as a union type</a>.</p>
<p>When Sorbet encounters a variable declaration like <code>x = true</code>, it infers the
type of <code>x</code> as <code>TrueClass</code>. An assignment to <code>x</code> later on in the same block such
as <code>x = false</code> would imply that the variable is reassigned to a different type
(namely, to <code>FalseClass</code> in this case).</p>
<p>For this reason, a loop such as the following triggers an error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declares `found_valid` with type `FalseClass`</span>
found_valid = <span class="hljs-literal">false</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Might change the type of `found_valid` to `TrueClass`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># error: Changing the type of a variable in a loop</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The fix, again, is to use <code>T.let</code> to widen the type to <code>T::Boolean</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declare `found_valid` with type `T::Boolean`</span>
found_valid = T.let(<span class="hljs-literal">false</span>, T::Boolean)

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Does not change the type of `found_valid`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7002"></a><a href="#7002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7002</h2>
<p>This is a standard type mismatch. A method’s <code>sig</code> declares one type, but the
actual value didn’t match. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-string">'str'</span> + <span class="hljs-symbol">:sym</span>  <span class="hljs-comment"># error: Expected `String` but found `Symbol(:"sym")` for argument `arg0`</span>
</code></pre>
<p>Even still, sometimes these errors can be rather confusing. Consider using
<a href="/docs/troubleshooting"><code>T.reveal_type</code></a> to pin down the origin of why Sorbet
thinks the types are what it says.</p>
<p><strong>Why does Sorbet think this is <code>nil</code>? I just checked that it’s not!</strong></p>
<p>That’s a <a href="flow-sensitive#limitations-of-flow-sensitivity">great question</a>, and
probably the most common question people have when using Sorbet!</p>
<p>It’s answered here:
<a href="flow-sensitive#limitations-of-flow-sensitivity">Limitations of flow-sensitivity</a></p>
<h2><a class="anchor" aria-hidden="true" id="7003"></a><a href="#7003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7003</h2>
<p>This error indicates a call to a method we believe does not exist (a la Ruby’s
<code>NoMethodError</code> exception). Some steps to debug:</p>
<ol>
<li><p>Double check that the code actually runs, either in the REPL, in CI, or with
manual tests. If the method doesn’t actually exist when run, Sorbet caught a
bug!</p></li>
<li><p>Even if the method exists when run, Sorbet still might report an error
because the method won’t <strong>always</strong> be there. For example, maybe the value
is <a href="/docs/nilable-types">nilable</a>, or we have a <a href="/docs/union-types">union</a> of a
handful of different types.</p></li>
<li><p>Many times, methods are defined dynamically in Ruby. Sorbet cannot see
methods defined with <code>define_method</code>. Sorbet also can’t see methods defined
using Ruby’s <code>included</code> + <code>other.extend(self)</code> pattern. For such dynamically
defined methods, Sorbet requires <code>*.rbi</code> files which define the method
statically.</p>
<p>See the <a href="/docs/rbi">RBI</a> docs for how to regenerate the <code>*.rbi</code> files.</p></li>
<li><p><a class="anchor" aria-hidden="true" id="include-kernel"></a>Sorbet will
complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span>;</span> <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> MyModule).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  x.<span class="hljs-literal">nil</span>? <span class="hljs-comment"># error: Method `nil?` does not exist on `MyModule`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The <code>nil?</code> method is defined on <code>Kernel</code> in Ruby. <code>Kernel</code> is included in
<code>Object</code> (which classes default to inheriting from), but not on
<code>BasicObject</code> (which classes can optionally inherit from).</p>
<p>The solution is to <code>include Kernel</code> in our module:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel
<span class="hljs-keyword">end</span>
</code></pre></li>
<li><p>Sorbet will complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The issue is similar to the above: <code>puts</code> is defined on <code>Kernel</code>, which is
not necessarily included in our module. For this situation, there are
actually two fixes:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 1: include Kernel</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 2: Kernel.puts</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> Kernel.puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre></li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="7004"></a><a href="#7004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7004</h2>
<p>This error indicates that a method has been called with incorrect parameters.
There are a few cases where this can occur:</p>
<ul>
<li>Too many parameters</li>
<li>Not enough parameters</li>
<li>Trying to pass parameters that don’t exist</li>
<li>Missing required parameters</li>
<li>Positional parameters used when the method expects named parameters, and vice
versa</li>
</ul>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-symbol">x:</span> <span class="hljs-literal">nil</span>)</span></span>; <span class="hljs-keyword">end</span>

foo(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">y:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
foo() <span class="hljs-comment"># ok</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-symbol">x:</span>)</span></span>; <span class="hljs-keyword">end</span>

bar() <span class="hljs-comment"># error</span>
bar(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
bar(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7005"></a><a href="#7005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7005</h2>
<p>Sorbet detected a mismatch between the declared return type for the method and
the type of the returned value:</p>
<pre><code class="hljs css language-rb">sig { returns(Integer) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">answer</span></span>
  <span class="hljs-string">"42"</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("42")` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Here we specified in the signature that <code>find</code> returns an instance of
<code>Configuration</code>, yet the returned value might be <code>nil</code>:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>A possible solution, if we are <em>certain</em> that <code>name</code> is in the <code>@lookup</code> hash,
is to use <code>T.must</code> when returning the value:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  T.must(@lookup[name])
<span class="hljs-keyword">end</span>
</code></pre>
<p>In some cases, we’re already being cautious and perform some checks before
returning yet Sorbet still complains about the return type:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> @lookup.key?(name)
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>While this code is correct, Sorbet cannot assume the state of <code>@lookup</code> didn’t
change between the <code>key?</code> check and the <code>[]</code> read. To fix this, we can take
advantage of flow-typing to make the whole method work without inline type
annotations:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  config = @lookup[name]
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> config
  config
<span class="hljs-keyword">end</span>
</code></pre>
<p>By using a local variable, we allow Sorbet to assert that <code>config</code> is never
nilable past the <code>raise</code> instruction.</p>
<h2><a class="anchor" aria-hidden="true" id="7006"></a><a href="#7006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7006</h2>
<p>In Sorbet, it is an error to have provably unreachable code. Because Sorbet is
<a href="/docs/flow-sensitive">sensitive to control flow</a> in a program, Sorbet can not only
track what types each variable has within all the branches of a conditional, but
also whether any given branch could be executed at all.</p>
<p>Erroring for dead or unreachable code is generally a way to prevent bugs. People
don’t usually expect that some branch of code is never taken; usually dead code
errors come from simple typos or misunderstandings about how Ruby works. In
particular: the only two “falsy” values in Ruby are <code>nil</code> and <code>false</code>.</p>
<p>Note if you intend for code to be dead because you’ve exhausted all the cases
and are trying to raise in the default case, use <code>T.absurd</code> to assert that a
case analysis is exhaustive. See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a>
for more information.</p>
<p>Sometimes, dead code errors can be hard to track down. The best way to pinpoint
the cause of a dead code error is to wrap variables or expressions in
<code>T.reveal_type(...)</code> to validate the assumptions that a piece of code is making.
For more troubleshooting tips, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<p>If for whatever reason it’s too hard to track down the cause of a dead code
error, it’s possible to silence it by making a variable or expression
“unanalyzable,” aka untyped. (When something is untyped, Sorbet will do very
limited flow-sensitivity analysis compared to if Sorbet knows the type. To make
something unanalyzable, we can wrap it in <code>T.unsafe(...)</code>:</p>
<pre><code class="hljs css language-ruby">x = <span class="hljs-literal">false</span>

<span class="hljs-keyword">if</span> x
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># error: This code is unreachable</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> T.unsafe(x)
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this (contrived) example, Sorbet knows statically that <code>x</code> is always <code>false</code>
and so our <code>puts</code> within the first <code>if</code> is never reachable. On the other hand,
Sorbet allows the second <code>if</code> because we’ve explicitly made <code>x</code> unanalyzable
with <code>T.unsafe(...)</code>. T.unsafe is one of a handful of
<a href="/docs/troubleshooting#escape-hatches">escape hatches</a> built into Sorbet.</p>
<h2><a class="anchor" aria-hidden="true" id="7007"></a><a href="#7007" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7007</h2>
<p>Sorbet can statically assert that the value passed into a <code>T.let</code> does not match
the expected type:</p>
<pre><code class="hljs css language-rb">x = T.let(<span class="hljs-number">1</span>, String) <span class="hljs-comment"># error: Argument does not have asserted type `String`</span>
</code></pre>
<p>Because of the way default values are desugared by Sorbet, this error also
occurs when Sorbet finds a mistmatch between the type specified for a parameter
in the signature and the default value provided in the method.</p>
<p>In this case, the signature states that <code>category</code> type is a <code>Category</code>, yet we
try to use <code>nil</code> as default value:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> Category).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span> <span class="hljs-comment"># error: Argument does not have asserted type `Category`</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If <code>category</code> value is <code>nil</code> by default, maybe we should make it so its type is
nilable:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> T.nilable(Category)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7009"></a><a href="#7009" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7009</h2>
<p>This error occurs when a value is used in place of a type. There are many
different situations where this can happen; one example is given below:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span></span>
  extend T::Generic

  E = type_member
<span class="hljs-keyword">end</span>

Box[<span class="hljs-literal">true</span>].new <span class="hljs-comment"># error: Unexpected bare `TrueClass` value found in type position</span>
</code></pre>
<p>More generally, Sorbet draws a distinction between places in a program where
Ruby values are allowed, and places where Sorbet type syntax is allowed. For
example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- Arbitrary type syntax allowed -----</span>
T.let(<span class="hljs-number">0</span>, T.any(Integer, String))
<span class="hljs-comment">#        ^^^^^^^^^^^^^^^^^^^^^^</span>
sig {returns(T.any(Integer, String))}
<span class="hljs-comment">#            ^^^^^^^^^^^^^^^^^^^^^^</span>
T::Array[T.any(Integer, String)].new
<span class="hljs-comment">#        ^^^^^^^^^^^^^^^^^^^^^^</span>


<span class="hljs-comment"># ----- Arbitrary type syntax NOT allowed -----</span>

<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">when</span> T.any(Integer, String)
<span class="hljs-comment">#    ^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="hljs-keyword">end</span>

x.is_a?(T.any(Integer, String))
<span class="hljs-comment">#       ^^^^^^^^^^^^^^^^^^^^^^</span>
</code></pre>
<p>Only valid Sorbet types are allowed in type positions. Arbitrary Sorbet types
are not allowed in most places where Ruby expects a normal value.</p>
<blockquote>
<p><strong>Note</strong>: Historically this error message has been one of the more confusing
Sorbet errors, and over time we have added special cases to detect common
points of confusion. If you’re reading this because you found the error
message confusing, please consider sharing your example with the Sorbet team
so we can further improve the error message.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7010"></a><a href="#7010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7010</h2>
<p>Sorbet found a reference to a generic type with the wrong number of type
arguments.</p>
<p>Here we defined <code>MyMap</code> as a generic class expecting two type parameters
<code>KeyType</code> and <code>ValueType</code> but we try to instantiate it with only one type
argument:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMap</span></span>
  extend T::Generic

  KeyType = type_member
  ValueType = type_member

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

MyMap[String].new <span class="hljs-comment"># error: Wrong number of type parameters for `MyMap`. Expected: `2`, got: `1`</span>
</code></pre>
<p>Unless a type member was <code>fixed</code>, it is always required to pass the correct
amount of type arguments. <code>T.untyped</code> can also be used if the type is not
relevant at this point:</p>
<pre><code class="hljs css language-rb">MyMap[String, Integer].new
MyMap[String, String].new
MyMap[String, T.untyped].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7011"></a><a href="#7011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7011</h2>
<p>Historically, users seeing this error has represented finding a bug in Sorbet
(or at least finding a test case for which there could be a better error
message). Consider searching for similar bugs at
<a href="https://github.com/sorbet/sorbet/issues">https://github.com/sorbet/sorbet/issues</a> or reporting a new one.</p>
<h2><a class="anchor" aria-hidden="true" id="7013"></a><a href="#7013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7013</h2>
<p>Sorbet detected that an instance variable was reassigned with different types:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">0</span>, Integer)
  <span class="hljs-keyword">end</span>

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @x = <span class="hljs-string">'not an integer'</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("not an integer")` for field</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If the instance variable can hold both an <code>Integer</code> and a <code>String</code>, maybe the
type specified with <code>T.let</code> should be enlarged:</p>
<pre><code class="hljs css language-ruby">@x = T.let(<span class="hljs-number">0</span>, T.any(Integer, String))
</code></pre>
<p>Similarly, Sorbet will reject constants reassigned with different types:</p>
<pre><code class="hljs css language-rb">FOO = <span class="hljs-number">42</span> <span class="hljs-comment"># error: Expected `String("Hello, world!")` but found `Integer(42)` for field</span>
FOO = <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7014"></a><a href="#7014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7014</h2>
<p>Sorbet has a special method called <code>T.reveal_type</code> which can be useful for
debugging. <code>T.reveal_type(expr)</code> will report an error in the output of <code>srb tc</code>
that shows what the static component of Sorbet thinks the result type of <code>expr</code>
is.</p>
<p>Making this an error is nice for two reasons:</p>
<ul>
<li><p>It makes our internal implementation easier 😅 We don’t have some special-case
messages and then error messages. The only thing Sorbet prints under normal
circumstances are error messages.</p></li>
<li><p>It serves as a reminder to remove <code>T.reveal_type</code> before committing a change.
Since it’s a proper error, Sorbet will exit with non-zero status until it’s
removed.</p></li>
</ul>
<p>For more information, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<blockquote>
<p>Looking for how to assert that an expression has a certain type? Check out
<a href="/docs/type-assertions">Type Assertions</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7015"></a><a href="#7015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7015</h2>
<p>Certain forms of <code>T.let</code>, <code>T.cast</code>, and <code>T.must</code> calls are redundant. Follow the
suggestion in the error message to fix—these errors should have an autocorrect
you can apply to automatically fix the error.</p>
<h2><a class="anchor" aria-hidden="true" id="7016"></a><a href="#7016" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7016</h2>
<p>Sorbet has special handling for certain methods in the standard library, like
<code>Array#flatten</code>. This method takes an optional <code>depth</code> argument, and will only
flatten nested arrays that deep if passed:</p>
<pre><code class="hljs css language-ruby">[[[[<span class="hljs-number">1</span>]]]].flatten(<span class="hljs-number">2</span>)

<span class="hljs-comment"># ERROR</span>
depth = T.let(<span class="hljs-number">2</span>, Integer)
[[[[<span class="hljs-number">1</span>]]]].flatten(depth)
</code></pre>
<p>Unfortunately, Sorbet can only perform this analysis when the depth is static.
If Sorbet cannot see the exact value of the depth and instead only sees a type
of <code>Integer</code> for the depth argument, it reports an error.</p>
<p>Either:</p>
<ol>
<li>Refactor the code so that Sorbet can see the exact depth value, or</li>
<li>Use <code>T.unsafe</code> to hide the method call from Sorbet.</li>
</ol>
<pre><code class="hljs css language-ruby">depth = T.let(<span class="hljs-number">2</span>, Integer)
<span class="hljs-comment"># `T.unsafe` disables static type checking for this call site,</span>
<span class="hljs-comment"># including the flatten depth check</span>
T.unsafe([[[[<span class="hljs-number">1</span>]]]]).flatten(depth)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7017"></a><a href="#7017" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7017</h2>
<p>In typed: strict files, Sorbet requires that all methods are annotated with a
<code>sig</code>. In a <code># typed: true</code> file Sorbet implicitly assumes that definitions
without types are <code>T.untyped</code>, but in a <code># typed: strict</code> file, Sorbet will no
longer make this implicit assumption.</p>
<p>You can still add a <code>sig</code> which declares the arguments or return as <code>T.untyped</code>,
so <code># typed: strict</code> does not outright ban <code>T.untyped</code>. The upside is that usage
of <code>T.untyped</code> is more explicit, which makes it easier to drive the number of
occurrences down. If you’re seeing this warning, there’s no time like the
present to add proper types to your public-facing API (i.e., your top-level
constant and method definitions)!</p>
<p>For how to fix, see <a href="/docs/sigs">Method Signatures</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#6002">6002</a>, <a href="#7028">7028</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7018"></a><a href="#7018" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7018</h2>
<p>At <code>typed: strong</code>, Sorbet no longer allows <code>T.untyped</code> as the intermediate
result of any method call. This effectively means that Sorbet knew the type
statically for 100% of calls within a file. This sigil is rarely used—usually
the only files that are <code># typed: strong</code> are RBI files and files with empty
class definitions. Most Ruby files that actually do interesting things will have
errors in <code># typed: strong</code>. Support for <code>typed: strong</code> files is minimal, as
Sorbet changes regularly and new features often bring new <code>T.untyped</code>
intermediate values.</p>
<h2><a class="anchor" aria-hidden="true" id="7019"></a><a href="#7019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7019</h2>
<p>Sorbet does not have great support for splats right now.</p>
<p>In general, when considering taking a variable number of arguments, consider
instead taking a single argument that’s an array instead of a “rest” arg:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
foo(*xs)
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>

sig {params(<span class="hljs-symbol">ys:</span> T::Array[Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(ys)</span></span>; <span class="hljs-keyword">end</span>

ys = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
bar(ys)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<p>If it is not possible to refactor the code, the current work around is to use
<code>T.unsafe</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- WORST CASE ----------------------------</span>
<span class="hljs-comment"># Prefer the solution described above</span>

sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
T.unsafe(<span class="hljs-keyword">self</span>).foo(xs)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7020"></a><a href="#7020" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7020</h2>
<p>Note that method-level generics (i.e., those declared by using <code>type_parameters</code>
inside a <code>sig</code>) are a somewhat unstable feature. If you encounter this error and
believe it to represent a bug in Sorbet, first check the
<a href="https://github.com/sorbet/sorbet/issues">Sorbet bug tracker</a> to see if a
similar-looking error has already been reported. If no such bug exists, feel
free to open an issue.</p>
<h2><a class="anchor" aria-hidden="true" id="7021"></a><a href="#7021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7021</h2>
<p>The called method declares a block parameter that is not <code>T.nilable</code> (making the
block argument required), but a block was not passed when it was called.</p>
<p>This can be fixed by either passing a block to the method, or changing the
method’s signature for the block parameter from <code>T.proc...</code> to
<code>T.nilable(T.proc...)</code> (and then changing the method to deal with a nilable
block parameter).</p>
<h2><a class="anchor" aria-hidden="true" id="7022"></a><a href="#7022" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7022</h2>
<p>When run with the <code>--suggest-typed</code> command line argument, Sorbet will suggest
upgrading or downgrading <code># typed:</code> sigils in all files in the project to the
highest level possible that would still have no errors. If the project starts
off with no errors initially, this should have the effect of only upgrading
sigils.</p>
<p>Accept the provided autocorrect suggestion to commit the upgrades (using the
<code>--autocorrect</code> flag).</p>
<h2><a class="anchor" aria-hidden="true" id="7023"></a><a href="#7023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7023</h2>
<p>This error occurs when a method is passed in a <code>Proc</code> object that Sorbet does
not know the arity for statically.</p>
<p>One instance where this can happen is when using <code>method</code>, since the arity of
method corresponding to the symbol is unknown. This can be fixed by passing in a
block with the correct arity:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

sig {params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">arg0:</span> String).void).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
foo(&amp;method(<span class="hljs-symbol">:puts</span>))
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>
foo <span class="hljs-keyword">do</span> <span class="hljs-params">|arg0|</span>
    method(<span class="hljs-symbol">:puts</span>).call(arg<span class="hljs-number">0</span>)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7024"></a><a href="#7024" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7024</h2>
<p>This error occurs when a generic argument is passed in as a block parameter.</p>
<p>In <code># typed: strict</code> files, using a parameter from a method that does not have a
signature will cause this issue to be reported. Adding a signature to the method
will fix the issue.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

<span class="hljs-comment"># ----- This will error -----------------------</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- This will not error -------------------</span>
sig {params(<span class="hljs-symbol">blk:</span> T.untyped).returns(T.untyped)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7026"></a><a href="#7026" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7026</h2>
<p>Sorbet detected that it was possible for <code>T.absurd</code> to be reached. This usually
means that something that was meant to cover all possible cases of a union type
did not cover all the cases.</p>
<p>See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="7027"></a><a href="#7027" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7027</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all constants are annotated
with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>, or accept the
autocorrect suggestion associated with this error.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#6002">6002</a>, <a href="#7017">7017</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7030"></a><a href="#7030" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7030</h2>
<p>This error is consistently used when the user is trying (implicitly or
explicitly) to call some method on a Sorbet type (e.g. <code>T::Array[Integer]</code>)
which would actually return a Sorbet-runtime representation of a type.</p>
<p>This error generally occurs when generic types are used in pattern matching:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_value</span><span class="hljs-params">(input)</span></span>
  <span class="hljs-keyword">case</span> input
  <span class="hljs-keyword">when</span> Integer
    input
  <span class="hljs-keyword">when</span> T::Array[Integer] <span class="hljs-comment"># error: Call to method `===` on `T::Array[Integer]` mistakes a type for a value</span>
    input.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since generic types are erased at runtime, this construct would never work when
the program executed. Replace the generic type <code>T::Array[Integer]</code> by the erased
type <code>Array</code> so the runtime behavior is correct:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_value</span><span class="hljs-params">(input)</span></span>
  <span class="hljs-keyword">case</span> input
  <span class="hljs-keyword">when</span> Integer
    input
  <span class="hljs-keyword">when</span> Array
    input.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7031"></a><a href="#7031" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7031</h2>
<p>Private methods in Ruby behave somewhat differently from private methods in
other statically typed languages. You may want to read more about
<a href="https://www.rubyguides.com/2018/10/method-visibility/">method visibility in Ruby</a>
first. The tl;dr is that private methods can only be called when the receiver is
<strong>syntactically</strong> <code>self</code> (or omitted):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  private <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_parent</span></span>
    foo      <span class="hljs-comment"># OK</span>
    <span class="hljs-keyword">self</span>.foo <span class="hljs-comment"># OK</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_child</span></span>
    foo      <span class="hljs-comment"># OK</span>
    <span class="hljs-keyword">self</span>.foo <span class="hljs-comment"># OK</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

Parent.new.foo <span class="hljs-comment"># error!</span>
Child.new.foo  <span class="hljs-comment"># error!</span>
</code></pre>
<p>This makes private methods in Ruby behave more like protected methods in other
object-oriented languages.</p>
<p>To fix this error, either:</p>
<ol>
<li>Avoid calling the private method entirely, or</li>
<li>Update the method definition to not be private, or</li>
<li>Use <code>.send(:foo, ...)</code> to ask Ruby to call the method ignoring visibility
checks.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: It’s not possible to silence this error using <code>T.unsafe</code>. Wrapping
the receiver in <code>T.unsafe</code> will in fact hide the method call from Sorbet
statically, but because method visibility is checked <strong>syntactically</strong>, even
using <code>T.unsafe(self).foo</code> will cause a call to a private method <code>foo</code> to be
rejected by the Ruby VM at runtime.</p>
<p>If you must call a private method and also silence any type errors from
calling it, you must use <code>self.send(:foo)</code> instead.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7032"></a><a href="#7032" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7032</h2>
<p>When passing type arguments to generic classes, to use <a href="/docs/shapes">shape types</a>,
use curly brackets around the keys and values of the shape type:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># CORRECT</span>
T::Array[{<span class="hljs-symbol">key:</span> Integer}].new

<span class="hljs-comment"># BAD</span>
T::Array[<span class="hljs-symbol">key:</span> Integer].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7033"></a><a href="#7033" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7033</h2>
<p><strong>Note</strong>: this error is only reported when Sorbet is passed the
<code>--ruby3-keyword-args</code> command line flag. For further information about Ruby 3
and keyword args, see the
<a href="https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/">official blog post</a>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span>Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_kwargs</span><span class="hljs-params">(x, <span class="hljs-symbol">y:</span>)</span></span>
<span class="hljs-keyword">end</span>

arghash = {<span class="hljs-symbol">y:</span> <span class="hljs-number">42</span>}

<span class="hljs-comment"># GOOD EXAMPLE</span>
takes_kwargs(<span class="hljs-number">99</span>, **arghash)

<span class="hljs-comment"># BAD EXAMPLE</span>
takes_kwargs(<span class="hljs-number">99</span>, arghash)
<span class="hljs-comment">#                ^^^^^^^ error: Keyword argument hash without `**`</span>
</code></pre>
<p><a href="https://sorbet.run/?arg=--ruby3-keyword-args#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams%28x%3A%20Integer%2C%20y%3AInteger%29.void%7D%0Adef%20takes_kwargs%28x%2C%20y%3A%29%0Aend%0A%0Aarghash%20%3D%20%7By%3A%2042%7D%0Atakes_kwargs%2899%2C%20arghash%29">→ View on sorbet.run</a></p>
<p>In Ruby 2.7 and earlier, Ruby allowed a positional <code>Hash</code> argument at the end of
a method call’s list of arguments to implicitly splat into the keyword
parameters of the method. In Ruby 3.0 and later, a positional <code>Hash</code> argument is
always treated as a positional argument. To avoid this error, prefix the <code>Hash</code>
argument with <code>**</code>, explicitly requesting to treat it as keyword arguments.</p>
<h2><a class="anchor" aria-hidden="true" id="7034"></a><a href="#7034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7034</h2>
<p>Sorbet detected that the safe navigation operator (<code>&amp;.</code>) was being used on a
receiver that can never be nil. Replace the offending occurrence of <code>&amp;.</code> with a
normal method call (<code>.</code>).</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span> T.nilable(Integer)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x, y)</span></span>
  puts x&amp;.to_s  <span class="hljs-comment"># error: x can never be nil</span>
  puts x.to_s   <span class="hljs-comment"># no error</span>

  puts y&amp;.to_s  <span class="hljs-comment"># no error: y may be nil</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7035"></a><a href="#7035" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7035</h2>
<p>Sorbet can sometimes detect when a method is passed a block despite not
accepting a block.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>
extend T::Sig

sig {void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_no_block</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-comment"># BAD EXAMPLE</span>
takes_no_block {} <span class="hljs-comment"># error: does not take a block</span>
</code></pre>
<p>Why only sometimes? Technically all methods in Ruby are allowed to accept
blocks. (Unlike positional arguments, if a method does not declare that it
accepts a block argument but a caller passes one anyways the Ruby VM does not
raise an exception.)</p>
<p>For historical reasons, Sorbet did not require that a <code>sig</code> mention the <code>blk</code>
parameter if its method used <code>yield</code> from the beginning of Sorbet adoption. It
later required this, but for reasons of backwards compatibility, it’s only
checked in <code># typed: strict</code> or higher files.</p>
<p>Therefore, error 7035 is somewhat special in that it can be reported in
<code># typed: true</code> files, but <strong>only</strong> if the method being passed a block is itself
defined in a <code># typed: strict</code> file.</p>
<p>Regardless, to fix this error, either:</p>
<ol>
<li>Remove the block from this call site (using the autocorrect), or</li>
<li>Update the called method’s definition to mention block argument, or</li>
<li>Drop the strictness level of file containing the called method’s definition
to <code># typed: true</code> or lower (<strong>only</strong> as a <strong>last resort</strong>).</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="7036"></a><a href="#7036" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7036</h2>
<p>Sorbet supports declaring package-private methods. These methods can only be
called from within the package where they are declared</p>
<p>To fix this error, either remove the <code>package_private</code> (or
<code>package_private_class_method</code>) annotation from the method definition, or
rewrite the code in question to not call the private method.</p>
<p>As a <strong>last</strong> resort, you can use <code>T.unsafe</code> to hide the method call from
Sorbet, silencing the error.</p>
<h2><a class="anchor" aria-hidden="true" id="7037"></a><a href="#7037" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7037</h2>
<p>See
<a href="/docs/flow-sensitive#limitations-of-flow-sensitivity">this doc for more information</a>.</p>
<p>In general, Sorbet can’t know that two calls to identical methods return
identical things, because in general methods are not pure.</p>
<p>Consider this example</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt; T::Struct</span>
  const <span class="hljs-symbol">:foo</span>, T.nilable(Integer)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> a.foo &amp;&amp; a.foo.even?
  <span class="hljs-comment">#         ^^^^^^^^^^^ error</span>
  puts a.foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, the call to <code>a.foo.even?</code> results in an error, even though we
checked that <code>a.foo</code> was not <code>nil</code> with the <code>&amp;&amp;</code>, because Sorbet does not assume
any methods are pure, not even methods defined with the <code>T::Struct</code> class’s
<code>const</code> DSL. (There are a number of technical and philosophical reasons why
Sorbet behaves this way, and we do not foresee these reasons changing).</p>
<p>There is always a simple solution, which is to either factor out the method
call’s result into a variable, or to use Ruby’s conditional method call operator
(<code>&amp;.</code>):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- solution 1 (preferred) --</span>
x = a.foo
<span class="hljs-keyword">if</span> x &amp;&amp; x.even?
  puts x
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- solution 2 --</span>
<span class="hljs-keyword">if</span> a.foo&amp;.even?
  puts a.foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>Of the two, the first solution is preferred because not only will the program
type check as written, but Sorbet will know that the <code>x</code> variable is not <code>nil</code>
throughout the body of the <code>if</code> statement.</p>
<h2><a class="anchor" aria-hidden="true" id="7038"></a><a href="#7038" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7038</h2>
<p>Consider this example:</p>
<pre><code class="hljs css language-ruby">sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:U</span>)
    .params(<span class="hljs-symbol">x:</span> T.type_parameter(<span class="hljs-symbol">:U</span>))
    .void
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  x.foo <span class="hljs-comment"># error!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This snippet declares a method <code>example</code> with a signature that says it can be
passed any input, but then attempts to call a specific method <code>.foo</code>.</p>
<p>Since this method can be given any type of value, Sorbet rejects the call to
<code>x.foo</code>.</p>
<p>To allow code like this, use <a href="/docs/abstract">interfaces</a> with
<a href="/docs/intersection-types">intersection types</a>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) Declare an interface</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IFoo</span></span>
  extend T::Sig
  extend T::Helpers
  interface!

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:U</span>)
    <span class="hljs-comment"># (2) Use the interface with an intersection type</span>
    .params(<span class="hljs-symbol">x:</span> T.all(IFoo, T.type_parameter(<span class="hljs-symbol">:U</span>)))
    .void
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  x.foo <span class="hljs-comment"># error!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Remember that in Sorbet, <a href="/docs/abstract">interfaces</a> must be explicitly
implemented in a given class.</p>
<!-- -->
<script src="/js/error-reference.js"></script>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/faq"><span class="arrow-prev">← </span><span>FAQ</span></a><a class="docs-next button" href="/docs/sigs"><span>Signatures</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#1001">1001</a></li><li><a href="#1003">1003</a></li><li><a href="#1004">1004</a></li><li><a href="#2001">2001</a></li><li><a href="#2003">2003</a></li><li><a href="#3001">3001</a></li><li><a href="#3002">3002</a></li><li><a href="#3011">3011</a></li><li><a href="#4001">4001</a></li><li><a href="#4002">4002</a></li><li><a href="#4003">4003</a></li><li><a href="#4006">4006</a></li><li><a href="#4010">4010</a></li><li><a href="#4011">4011</a></li><li><a href="#4012">4012</a></li><li><a href="#4013">4013</a></li><li><a href="#4014">4014</a></li><li><a href="#4015">4015</a></li><li><a href="#4016">4016</a></li><li><a href="#4019">4019</a></li><li><a href="#4021">4021</a></li><li><a href="#5001">5001</a></li><li><a href="#5002">5002</a></li><li><a href="#5005">5005</a></li><li><a href="#5006">5006</a></li><li><a href="#5008">5008</a></li><li><a href="#5011">5011</a></li><li><a href="#5012">5012</a></li><li><a href="#5013">5013</a></li><li><a href="#5014">5014</a></li><li><a href="#5023">5023</a></li><li><a href="#5028">5028</a></li><li><a href="#5034">5034</a></li><li><a href="#5035">5035</a></li><li><a href="#5036">5036</a></li><li><a href="#5037">5037</a></li><li><a href="#5041">5041</a></li><li><a href="#5046">5046</a></li><li><a href="#5047">5047</a></li><li><a href="#5048">5048</a></li><li><a href="#5054">5054</a></li><li><a href="#5056">5056</a></li><li><a href="#5057">5057</a></li><li><a href="#5058">5058</a></li><li><a href="#5064">5064</a></li><li><a href="#5068">5068</a></li><li><a href="#6001">6001</a></li><li><a href="#6002">6002</a></li><li><a href="#6004">6004</a></li><li><a href="#6005">6005</a></li><li><a href="#7001">7001</a></li><li><a href="#7002">7002</a></li><li><a href="#7003">7003</a></li><li><a href="#7004">7004</a></li><li><a href="#7005">7005</a></li><li><a href="#7006">7006</a></li><li><a href="#7007">7007</a></li><li><a href="#7009">7009</a></li><li><a href="#7010">7010</a></li><li><a href="#7011">7011</a></li><li><a href="#7013">7013</a></li><li><a href="#7014">7014</a></li><li><a href="#7015">7015</a></li><li><a href="#7016">7016</a></li><li><a href="#7017">7017</a></li><li><a href="#7018">7018</a></li><li><a href="#7019">7019</a></li><li><a href="#7020">7020</a></li><li><a href="#7021">7021</a></li><li><a href="#7022">7022</a></li><li><a href="#7023">7023</a></li><li><a href="#7024">7024</a></li><li><a href="#7026">7026</a></li><li><a href="#7027">7027</a></li><li><a href="#7030">7030</a></li><li><a href="#7031">7031</a></li><li><a href="#7032">7032</a></li><li><a href="#7033">7033</a></li><li><a href="#7034">7034</a></li><li><a href="#7035">7035</a></li><li><a href="#7036">7036</a></li><li><a href="#7037">7037</a></li><li><a href="#7038">7038</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>