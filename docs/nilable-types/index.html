<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Nilable Types · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Sorbet can track when a value is allowed to be `nil`, or when a value of a"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Nilable Types · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="Sorbet can track when a value is allowed to be `nil`, or when a value of a"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/nilable-types.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Nilable Types</h1></header><article><div><span><p>Sorbet can track when a value is allowed to be <code>nil</code>, or when a value of a
certain type must be present. In Sorbet, such a type is called a <strong>nilable</strong>
type. In Sorbet, types are non-nil by default. We have to explicitly opt a type
into allowing <code>nil</code> by wrapping it in <code>T.nilable(...)</code>:</p>
<pre><code class="hljs css language-ruby">T.nilable(String)
</code></pre>
<p>Valid values for this type are either <code>nil</code> or any Ruby string. Once we have
something of a nilable type, we can use it like this:</p>
<pre><code class="hljs css language-ruby">extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> T.nilable(String)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-keyword">if</span> x
    puts <span class="hljs-string">"x was not nil! Got: <span class="hljs-subst">#{x}</span>"</span>
  <span class="hljs-keyword">else</span>
    puts <span class="hljs-string">"x was nil"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tracking-nil"></a><a href="#tracking-nil" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tracking <code>nil</code></h2>
<p>Sorbet is smart enough to follow the control flow of a program to update its
knowledge about what types each variable has within each branch. For example, if
we have a method that declares it can only be given something that’s not <code>nil</code>,
Sorbet will force us to first check whether our variable is <code>nil</code>:</p>
<pre><code class="hljs css language-ruby">extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> String).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">must_be_given_string</span><span class="hljs-params">(x)</span></span>
  puts <span class="hljs-string">"Got string: <span class="hljs-subst">#{x}</span>"</span>
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> T.nilable(String)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  must_be_given_string(x) <span class="hljs-comment"># error: Expected `String` but found `T.nilable(String)` for argument `x`</span>
  <span class="hljs-keyword">if</span> x
    must_be_given_string(x) <span class="hljs-comment"># ok</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#extend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20String).void%7D%0Adef%20must_be_given_string(x)%0A%20%20puts%20%22Got%20string%3A%20%23%7Bx%7D%22%0Aend%0A%0Asig%20%7Bparams(x%3A%20T.nilable(String)).void%7D%0Adef%20foo(x)%0A%20%20must_be_given_string(x)%20%23%20error%3A%20%0A%20%20if%20x%0A%20%20%20%20must_be_given_string(x)%20%23%20ok%0A%20%20end%0Aend">
→ View on sorbet.run
</a></p>
<p>This is one of the most useful features of Sorbet. Many bugs can be prevented by
ensuring when something is <code>nil</code> and when something is not <code>nil</code>! For more
information on how this control flow-sensitivity works and how to take full
advantage of it, see <a href="/docs/flow-sensitive">Flow-sensitive Typing</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="tmust-asserting-that-something-is-not-nil"></a><a href="#tmust-asserting-that-something-is-not-nil" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.must</code>: Asserting that something is not <code>nil</code></h2>
<p>When Sorbet reports an error about a type mismatch, we strongly encourage
thinking through what it means. For example, in which situations could this be
<code>nil</code>? Is there some sensible behavior when given <code>nil</code>? Sometimes accepting
<code>nil</code> makes sense, and other times we’d like to never take something that’s nil
and request that the caller filter out <code>nil</code> values before even calling our
method.</p>
<p>However, sometimes either</p>
<ul>
<li>we’re sure this thing can never be nil, or</li>
<li>it isn’t valuable to spend the time handling the <code>nil</code> case.</li>
</ul>
<p>In cases like these, we can use <code>T.must</code> to silence the error. Let’s walk
through an example to see how it works. Consider this code with an error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesnt_take_nil</span><span class="hljs-params">(x)</span></span>; <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">key:</span> Symbol, <span class="hljs-symbol">options:</span> T::Hash[Symbol, Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(key, options)</span></span>
  val = options[key]
  doesnt_take_nil(val) <span class="hljs-comment"># error: Expected `Integer` but found `T.nilable(Integer)` for argument `x`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, <code>foo</code> accepts a Hash with <code>Symbol</code> keys and <code>Integer</code> values.
We looked up the element in the Hash at key <code>key</code>, got back <code>val</code>, and passed it
to <code>doesnt_take_nil</code>. Here, Sorbet complains, because <code>val</code> could be <code>nil</code> (if
the key doesn’t exist in the hash).</p>
<p>In general, there’s no way to know whether <code>key</code> is in <code>options</code>, but we might
have special knowledge (that Sorbet doesn’t know) to convince us that <code>val</code> will
never be <code>nil</code>. Maybe:</p>
<ul>
<li>this code runs in production very frequently, with no issues.</li>
<li>our test suite has good coverage for this code.</li>
<li>we validate that <code>key</code> is a valid key somewhere higher up in our code.</li>
</ul>
<p>When we’re <strong>sure</strong> that <code>val</code> must never be <code>nil</code>, we can wrap it in
<code>T.must(...)</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doesnt_take_nil</span><span class="hljs-params">(x)</span></span>; <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">key:</span> Symbol, <span class="hljs-symbol">options:</span> T::Hash[Symbol, Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(key, options)</span></span>
  val = T.must(options[key])
  doesnt_take_nil(val) <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Using <code>T.must</code> is akin to saying “Sorbet, please trust me: at runtime this value
will never be <code>nil</code>.” In essence, we’re trading off static guarantees for
runtime guarantees. Put another way, we’re shifting the “burden of proof” for
this code’s correctness from Sorbet to the programmer, and we as programmers can
“prove” that this code is not nil using whatever means is convenient (tests,
observability, etc.). In fact, it’s the same tradeoff we make every time we
<code>raise</code> an exception, and comes with the same set of caution labels:</p>
<blockquote>
<p><strong>Note</strong>: Like all other type checks in Sorbet, <code>T.must</code> will raise at runtime
if it fails. For more information, see <a href="/docs/runtime">Enabling Runtime Checks</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="alternatives-to-tmust"></a><a href="#alternatives-to-tmust" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Alternatives to <code>T.must</code></h2>
<p>Sometimes <code>T.must</code> can “clutter up” code, so here are some alternatives that
accomplish the same thing as or something similar to <code>T.must</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="arrayfetch--hashfetch"></a><a href="#arrayfetch--hashfetch" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Array#fetch</code> &amp; <code>Hash#fetch</code></h3>
<p>The Ruby standard library has a couple built-in methods for raising an exception
if an element is missing from a collection: <code>x.fetch(...)</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Our `T.must` from the previous section's example:</span>
val = T.must(options[key])

<span class="hljs-comment"># The same thing, but with `fetch`:</span>
val = options.fetch(key)
</code></pre>
<p>Like <code>T.must</code>, <code>fetch</code> will raise if the key is not found. Using <code>fetch</code> is
convenient because we can also provide a default value to use when the key
doesn’t exist:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Use `0` for `val` if key is not found:</span>
val = options.fetch(key, <span class="hljs-number">0</span>)
</code></pre>
<p>Written this way, this line will never raise an exception and <code>val</code> will never
be <code>nil</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="-the-safe-navigation-operator"></a><a href="#-the-safe-navigation-operator" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>&amp;.</code>: The safe navigation operator</h3>
<p>Ruby 2.3 added special syntax to the language to do something like <code>x&amp;.foo</code>,
which means “call <code>foo</code> if <code>x</code> is not <code>nil</code>, otherwise short circuit and
evaluate to <code>nil</code>.” This is similar to <code>T.must</code>, but not quite the same.
Consider:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1)</span>
val = T.must(x).foo

<span class="hljs-comment"># (2)</span>
val = x&amp;.foo
</code></pre>
<p>In (1), if <code>x</code> is nil the code will raise an exception, and <code>val</code> will never be
<code>nil</code>. But in (2), the code will not raise an exception, but <code>val</code> might be
<code>nil</code>. Here’s a longer example:</p>
<pre><code class="hljs css language-ruby">extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> T.nilable(Integer)).returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  y = T.must(x).abs
  T.reveal_type(y)
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> T.nilable(Integer)).returns(T.nilable(Integer))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(x)</span></span>
  y = x&amp;.abs
  T.reveal_type(y)
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#extend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.nilable(Integer)).returns(Integer)%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20T.must(x).abs%0A%20%20T.reveal_type(y)%0Aend%0A%0Asig%20%7Bparams(x%3A%20T.nilable(Integer)).returns(T.nilable(Integer))%7D%0Adef%20bar(x)%0A%20%20y%20%3D%20x%26.abs%0A%20%20T.reveal_type(y)%0Aend">
→ View on sorbet.run
</a></p>
<h3><a class="anchor" aria-hidden="true" id="other-escape-hatches"></a><a href="#other-escape-hatches" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other escape hatches</h3>
<p><code>T.must</code> is one of the handful of escape hatches in Sorbet. For more
information, see <a href="/docs/troubleshooting#escape-hatches">escape hatches</a>.</p>
<p>Also, people frequently confuse <code>T.must</code> with <code>T.let</code>, <code>T.cast</code>, and <code>T.unsafe</code>.
Each of these four are actually rather different; for the differences, see
<a href="/docs/type-assertions">Type Assertions</a>.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/stdlib-generics"><span class="arrow-prev">← </span><span>Arrays &amp; Hashes</span></a><a class="docs-next button" href="/docs/union-types"><span>Union Types (T.any)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#tracking-nil">Tracking <code>nil</code></a></li><li><a href="#tmust-asserting-that-something-is-not-nil"><code>T.must</code>: Asserting that something is not <code>nil</code></a></li><li><a href="#alternatives-to-tmust">Alternatives to <code>T.must</code></a><ul class="toc-headings"><li><a href="#arrayfetch--hashfetch"><code>Array#fetch</code> &amp; <code>Hash#fetch</code></a></li><li><a href="#-the-safe-navigation-operator"><code>&amp;.</code>: The safe navigation operator</a></li><li><a href="#other-escape-hatches">Other escape hatches</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>