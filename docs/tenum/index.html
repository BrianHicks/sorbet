<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Typed Enums via T::Enum · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Enumerations allow for type-safe declarations of a fixed set of values. &quot;Type"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Typed Enums via T::Enum · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="Enumerations allow for type-safe declarations of a fixed set of values. &quot;Type"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/tenum.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Typed Enums via T::Enum</h1></header><article><div><span><p>Enumerations allow for type-safe declarations of a fixed set of values. “Type
safe” means that the values in this set are the only values that belong to this
type. Here’s an example of how to define a typed enum with Sorbet:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) New enumerations are defined by creating a subclass of T::Enum</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suit</span> &lt; T::Enum</span>
  <span class="hljs-comment"># (2) Enum values are declared within an `enums do` block</span>
  enums <span class="hljs-keyword">do</span>
    Spades = new
    Hearts = new
    Clubs = new
    Diamonds = new
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note how each enum value is created by calling <code>new</code>: each enum value is an
instance of the enumeration class itself. This means that
<code>Suit::Spades.is_a?(Suit)</code>, and the same for all the other enum values. This
guarantees that one enum value cannot be used where some other type is expected,
and vice versa.</p>
<p>This also means that once an enum has been defined as a subclass of <code>T::Enum</code>,
it behaves like any other <a href="/docs/class-types">Class Type</a> and can be used in method
signatures, type aliases, <code>T.let</code> annotations, and any other place a class type
can be used:</p>
<pre><code class="hljs css language-ruby">sig {returns(Suit)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_suit</span></span>
  T.cast(Suit.values.sample, Suit)
<span class="hljs-keyword">end</span>
</code></pre>
<blockquote>
<p>The <code>T.cast</code> is necessary because of how
<a href="/docs/faq#sigs-are-vague-for-stdlib-methods-that-accept-keyword-arguments--have-multiple-return-types">Sorbet behaves with <code>Array#sample</code></a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="exhaustiveness"></a><a href="#exhaustiveness" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exhaustiveness</h2>
<p>Sorbet knows about the values in an enumeration statically, and so it can use
<a href="/docs/exhaustiveness">exhaustiveness checking</a> to check whether all enum values
have been considered. The easiest way is to use a <code>case</code> statement:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">suit:</span> Suit).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">describe_suit_color</span><span class="hljs-params">(suit)</span></span>
  <span class="hljs-keyword">case</span> suit
  <span class="hljs-keyword">when</span> Suit::Spades   <span class="hljs-keyword">then</span> puts <span class="hljs-string">"Spades are black!"</span>
  <span class="hljs-keyword">when</span> Suit::Hearts   <span class="hljs-keyword">then</span> puts <span class="hljs-string">"Hearts are red!"</span>
  <span class="hljs-keyword">when</span> Suit::Clubs    <span class="hljs-keyword">then</span> puts <span class="hljs-string">"Clubs are black!"</span>
  <span class="hljs-keyword">when</span> Suit::Diamonds <span class="hljs-keyword">then</span> puts <span class="hljs-string">"Diamonds are red!"</span>
  <span class="hljs-keyword">else</span> T.absurd(suit)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Because of the call to <code>T.absurd</code>, if any of the individual suits had not been
handled, Sorbet would report an error statically that one of the cases was
missing. For more information on how exhaustiveness checking works, see
<a href="/docs/exhaustiveness">Exhaustiveness Checking</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="enum-values-in-types"></a><a href="#enum-values-in-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enum values in types</h2>
<p>We might want a type for “only red suits” or “only black suits.” <code>T::Enum</code>
allows using individual enum values like <code>Suit::Hearts</code> or <code>Suit::Diamonds</code> as
types (in addition to the name of the enum itself, like <code>Suit</code>):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) Hearts and Diamonds are enum values and also types</span>
sig {params(<span class="hljs-symbol">red_suit:</span> T.any(Suit::Hearts, Suit::Diamonds)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_red_suit</span><span class="hljs-params">(red_suit)</span></span>
  <span class="hljs-keyword">case</span> red_suit
  <span class="hljs-keyword">when</span> Suit::Hearts <span class="hljs-keyword">then</span> <span class="hljs-string">"..."</span>
  <span class="hljs-keyword">when</span> Suit::Diamonds <span class="hljs-keyword">then</span> <span class="hljs-string">"..."</span>
  <span class="hljs-comment"># (2) exhaustive, even with only two cases handled</span>
  <span class="hljs-keyword">else</span> T.absurd(red_suit)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

handle_red_suit(Suit::Hearts) <span class="hljs-comment"># ok</span>
handle_red_suit(Suit::Spades) <span class="hljs-comment"># type error</span>
</code></pre>
<p>We can also define <a href="/docs/type-aliases">type aliases</a> of various groups of enum
values:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Two type aliases for two different enum subsets</span>
RedSuit = T.type_alias {T.any(Suit::Hearts, Suit::Diamonds)}
BlackSuit = T.type_alias {T.any(Suit::Spades, Suit::Clubs)}

sig {params(<span class="hljs-symbol">black_suit:</span> BlackSuit).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle_black_suit</span><span class="hljs-params">(black_suit)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Using enum values in types is useful for modeling enums where there is a
frequently-used subset of enum values.</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0A%23%20(1)%20New%20enumerations%20are%20defined%20by%20creating%20a%20subclass%20of%20T%3A%3AEnum%0Aclass%20Suit%20%3C%20T%3A%3AEnum%0A%20%20%23%20(2)%20Enum%20values%20are%20declared%20within%20an%20%60enums%20do%60%20block%0A%20%20enums%20do%0A%20%20%20%20Spades%20%3D%20new%0A%20%20%20%20Hearts%20%3D%20new%0A%20%20%20%20Clubs%20%3D%20new%0A%20%20%20%20Diamonds%20%3D%20new%0A%20%20end%0Aend%0A%0Asig%20%7Bparams(red_suit%3A%20T.any(Suit%3A%3AHearts%2C%20Suit%3A%3ADiamonds)).void%7D%0Adef%20handle_red_suit(red_suit)%0A%20%20case%20red_suit%0A%20%20when%20Suit%3A%3AHearts%20then%20%22...%22%0A%20%20when%20Suit%3A%3ADiamonds%20then%20%22...%22%0A%20%20%23%20exhaustive%2C%20even%20with%20only%20two%20cases%20handled%0A%20%20else%20T.absurd(red_suit)%0A%20%20end%0Aend%0A%0Ahandle_red_suit(Suit%3A%3AHearts)%20%23%20ok%0Ahandle_red_suit(Suit%3A%3ASpades)%20%23%20type%20error%0A%0ARedSuit%20%3D%20T.type_alias%20%7BT.any(Suit%3A%3AHearts%2C%20Suit%3A%3ADiamonds)%7D%0ABlackSuit%20%3D%20T.type_alias%20%7BT.any(Suit%3A%3ASpades%2C%20Suit%3A%3AClubs)%7D%0A%0Asig%20%7Bparams(black_suit%3A%20BlackSuit).void%7D%0Adef%20handle_black_suit(black_suit)%0A%20%20case%20black_suit%0A%20%20when%20Suit%3A%3ASpades%20then%20%22...%22%0A%20%20when%20Suit%3A%3AClubs%20then%20%22...%22%0A%20%20%23%20exhaustive%2C%20even%20with%20only%20two%20cases%20handled%0A%20%20else%20T.absurd(black_suit)%0A%20%20end%0Aend%0A">→
View full example on sorbet.run</a></p>
<h2><a class="anchor" aria-hidden="true" id="converting-enums-to-other-types"></a><a href="#converting-enums-to-other-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Converting enums to other types</h2>
<p>Enumerations do not implicitly convert to any other type. Instead, all
conversion must be done explicitly. One particularly convenient way to implement
these conversion functions is to define instance methods on the enum class
itself:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suit</span> &lt; T::Enum</span>
  enums <span class="hljs-keyword">do</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>

  sig {returns(Integer)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rank</span></span>
    <span class="hljs-comment"># (1) Case on self (because this is an instance method)</span>
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">self</span>
    <span class="hljs-keyword">when</span> Spades <span class="hljs-keyword">then</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">when</span> Hearts <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">when</span> Clubs <span class="hljs-keyword">then</span> <span class="hljs-number">3</span>
    <span class="hljs-keyword">when</span> Diamonds <span class="hljs-keyword">then</span> <span class="hljs-number">4</span>
    <span class="hljs-keyword">else</span>
      <span class="hljs-comment"># (2) Exhaustiveness still works when casing on `self`</span>
      T.absurd(<span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>A particularly common case is to convert an enum to a String. Because this is so
common, this conversion method is built in:</p>
<pre><code class="hljs css language-ruby">Suit::Spades.serialize <span class="hljs-comment"># =&gt; 'spades'</span>
Suit::Hearts.serialize <span class="hljs-comment"># =&gt; 'hearts'</span>
<span class="hljs-comment"># ...</span>
</code></pre>
<p>Again: this conversion to a string must still be done explicitly. When
attempting to implicitly convert an enum value to a string, you’ll get a
non-human-friendly representation of the enum:</p>
<pre><code class="hljs css language-ruby">suit = Suit::Spades
puts <span class="hljs-string">"Got suit: <span class="hljs-subst">#{suit}</span>"</span>
<span class="hljs-comment"># =&gt;  Got suit: #&lt;Suit::Spades&gt;</span>
</code></pre>
<p>The default value used for serializing an enum is the name of the enum, all
lowercase. To specify an alternative serialized value, pass an argument to
<code>new</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suit</span> &lt; T::Enum</span>
  enums <span class="hljs-keyword">do</span>
    Spades = new(<span class="hljs-string">'SPADES'</span>)
    Hearts = new(<span class="hljs-string">'HEARTS'</span>)
    Clubs = new(<span class="hljs-string">'CLUBS'</span>)
    Diamonds = new(<span class="hljs-string">'DIAMONDS'</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

Suit::Diamonds.serialize <span class="hljs-comment"># =&gt; 'DIAMONDS'</span>
</code></pre>
<p>Each serialized value must be unique compared to all other serialized values for
this enum. The argument to <code>new</code> currently accepts <code>T.untyped</code>, meaning you can
pass any value to <code>new</code> (including things like <code>Symbol</code>s or <code>Integer</code>s). A
future change to Sorbet may restrict this; we strongly recommend that you pass
<code>String</code> values as the explicit serialization values.</p>
<h2><a class="anchor" aria-hidden="true" id="converting-from-other-types-to-enums"></a><a href="#converting-from-other-types-to-enums" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Converting from other types to enums</h2>
<p>Another common conversion is to take the serialized value and deserialize it
back to the original enum value. This is also built into <code>T::Enum</code>:</p>
<pre><code class="hljs css language-ruby">serialized = Suit::Spades.serialize
suit = Suit.deserialize(serialized)

puts suit
<span class="hljs-comment"># =&gt; #&lt;Suit::Spades&gt;</span>
</code></pre>
<p>When the value being deserialized doesn’t exist, a <code>KeyError</code> exception is
raised:</p>
<pre><code class="hljs css language-ruby">Suit.deserialize(<span class="hljs-string">'bad value'</span>)
<span class="hljs-comment"># =&gt; KeyError: Enum Suit key not found: "bad value"</span>
</code></pre>
<p>If this is not the behavior you want, you can use <code>try_deserialize</code> which
returns <code>nil</code> when the value doesn’t deserialize to anything:</p>
<pre><code class="hljs css language-ruby">Suit.try_deserialize(<span class="hljs-string">'bad value'</span>)
<span class="hljs-comment"># =&gt; nil</span>
</code></pre>
<p>You can also ask whether a specific serialized value exists for an enum:</p>
<pre><code class="hljs css language-ruby">Suit.has_serialized?(Suit::Spades.serialize)
<span class="hljs-comment"># =&gt; true</span>

Suit.has_serialized?(<span class="hljs-string">'bad value'</span>)
<span class="hljs-comment"># =&gt; false</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="listing-the-values-of-an-enum"></a><a href="#listing-the-values-of-an-enum" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listing the values of an enum</h2>
<p>Sometimes it is useful to enumerate all the values of an enum:</p>
<pre><code class="hljs css language-ruby">Suit.values
<span class="hljs-comment"># =&gt; [#&lt;Suit::Spades&gt;, #&lt;Suit::Heart&gt;, #&lt;Suit::Clubs&gt;, #&lt;Suit::Diamonds&gt;]</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="attaching-metadata-to-an-enum"></a><a href="#attaching-metadata-to-an-enum" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Attaching metadata to an enum</h2>
<p>It can be tempting to “attach metadata” to each enum value by overriding the
constructor for a <code>T::Enum</code> subclass such that it accepts more information and
stores it on an instance variable.</p>
<p>This is <strong>strongly discouraged</strong>. It’s likely that Sorbet will enforce this
discouragement with a future change.</p>
<p>Concretely, consider some code like this that is discouraged:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aclass%20Suit%20%3C%20T%3A%3AEnum%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Breturns(Integer)%7D%0A%20%20attr_reader%20%3Arank%0A%0A%20%20sig%20%7Bparams(serialized_val%3A%20String%2C%20rank%3A%20Integer).void%7D%0A%20%20def%20initialize(serialized_val%2C%20rank)%0A%20%20%20%20super(serialized_val)%0A%20%20%20%20%40rank%20%3D%20T.let(rank%2C%20Integer)%0A%20%20end%0A%0A%20%20enums%20do%0A%20%20%20%20Spades%20%3D%20new('spades'%2C%201)%0A%20%20%20%20Hearts%20%3D%20new('hearts'%2C%202)%0A%20%20%20%20Clubs%20%3D%20new('clubs'%2C%203)%0A%20%20%20%20Diamonds%20%3D%20new('diamonds'%2C%204)%0A%20%20end%0Aend%0A">→
View on sorbet.run</a></p>
<p>This code is discouraged because it…</p>
<ul>
<li>overrides the <code>T::Enum</code> constructor, making it brittle to potential future
changes in the <code>T::Enum</code> API.</li>
<li>stores state on each enum value. Enum values are singleton instances, meaning
that if someone accidentally mutates this state, it’s observed globally
throughout an entire program.</li>
</ul>
<p>Rather than thinking of enums as data containers, instead think of them as dumb
immutable values. A more idiomatic way to express the code above looks similar
to the example given in the section
<a href="#converting-enums-to-other-types">Converting enums to other types</a> above:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Suit</span> &lt; T::Enum</span>
  extend T::Sig

  enums <span class="hljs-keyword">do</span>
    Spades = new
    Hearts = new
    Clubs = new
    Diamonds = new
  <span class="hljs-keyword">end</span>

  sig {returns(Integer)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rank</span></span>
    <span class="hljs-keyword">case</span> <span class="hljs-keyword">self</span>
    <span class="hljs-keyword">when</span> Spades <span class="hljs-keyword">then</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">when</span> Hearts <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">when</span> Clubs <span class="hljs-keyword">then</span> <span class="hljs-number">3</span>
    <span class="hljs-keyword">when</span> Diamonds <span class="hljs-keyword">then</span> <span class="hljs-number">4</span>
    <span class="hljs-keyword">else</span> T.absurd(<span class="hljs-keyword">self</span>)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aclass%20Suit%20%3C%20T%3A%3AEnum%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20enums%20do%0A%20%20%20%20Spades%20%3D%20new%0A%20%20%20%20Hearts%20%3D%20new%0A%20%20%20%20Clubs%20%3D%20new%0A%20%20%20%20Diamonds%20%3D%20new%0A%20%20end%0A%0A%20%20sig%20%7Breturns(Integer)%7D%0A%20%20def%20rank%0A%20%20%20%20case%20self%0A%20%20%20%20when%20Spades%20then%201%0A%20%20%20%20when%20Hearts%20then%202%0A%20%20%20%20when%20Clubs%20then%203%0A%20%20%20%20when%20Diamonds%20then%204%0A%20%20%20%20else%20T.absurd(self)%0A%20%20%20%20end%0A%20%20end%0Aend">→
View on sorbet.run</a></p>
<p>This example uses <a href="/docs/exhaustiveness">exhaustiveness</a> on the enum to associate a
rank with each suit. It does this without needing to override anything built
into <code>T::Enum</code>, and without mutating state.</p>
<blockquote>
<p>If you need exhaustiveness over a set of cases which do carry data, see
<a href="/docs/sealed#approximating-algebraic-data-types">Approximating algebraic data types</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="defining-one-enum-as-a-subset-of-another-enum"></a><a href="#defining-one-enum-as-a-subset-of-another-enum" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining one enum as a subset of another enum</h2>
<blockquote>
<p>This section has been superseded by the
<a href="#enum-values-in-types">Enum values in types</a> section above. This section is
older, and describes workarounds relevant before that section above existed.
We include this section here mostly for inspiration (the ideas in this section
are not discouraged, just verbose).</p>
</blockquote>
<p>In addition to using <a href="#enum-values-in-types">enum values in types</a> and type
aliases of enum values, there are two other ways to define one enum as a subset
of another:</p>
<ol>
<li>By using a <a href="/docs/sealed">sealed module</a></li>
<li>By explicitly converting between multiple enums</li>
</ol>
<p>Let’s elaborate on those two one at a time.</p>
<p>All the examples below will be for days of the week. There are 7 days total, but
there are two clear groups: weekdays and weekends, and sometimes it makes sense
to have the type system enforce that a value can <strong>only</strong> be a weekday enum
value or <strong>only</strong> a weekend enum value.</p>
<h3><a class="anchor" aria-hidden="true" id="by-using-a-sealed-module"></a><a href="#by-using-a-sealed-module" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>By using a sealed module</h3>
<p><a href="/docs/sealed">Sealed modules</a> are a way to limit where a module is allowed to be
included. See <a href="/docs/sealed">the docs</a> if you’d like to learn more, but here’s how
they can be used together with <code>T::Enum</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) Define an interface / module</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">DayOfWeek</span></span>
  extend T::Helpers
  sealed!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weekday</span> &lt; T::Enum</span>
  <span class="hljs-comment"># (2) include DayOfWeek when defining the Weekday enum</span>
  <span class="hljs-keyword">include</span> DayOfWeek

  enums <span class="hljs-keyword">do</span>
    Monday = new
    Tuesday = new
    Wednesday = new
    Thursday = new
    Friday = new
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weekend</span> &lt; T::Enum</span>
  <span class="hljs-comment"># (3) ditto</span>
  <span class="hljs-keyword">include</span> DayOfWeek

  enums <span class="hljs-keyword">do</span>
    Saturday = new
    Sunday = new
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aclass%20Module%0A%20%20include%20T%3A%3ASig%0Aend%0A%0Amodule%20DayOfWeek%0A%20%20extend%20T%3A%3AHelpers%0A%20%20sealed!%0Aend%0A%0Aclass%20Weekday%20%3C%20T%3A%3AEnum%0A%20%20include%20DayOfWeek%0A%0A%20%20enums%20do%0A%20%20%20%20Monday%20%3D%20new%0A%20%20%20%20Tuesday%20%3D%20new%0A%20%20%20%20Wednesday%20%3D%20new%0A%20%20%20%20Thursday%20%3D%20new%0A%20%20%20%20Friday%20%3D%20new%0A%20%20end%0Aend%0A%0Aclass%20Weekend%20%3C%20T%3A%3AEnum%0A%20%20include%20DayOfWeek%0A%0A%20%20enums%20do%0A%20%20%20%20Saturday%20%3D%20new%0A%20%20%20%20Sunday%20%3D%20new%0A%20%20end%0Aend%0A%0Asig%20%7Bparams(day%3A%20DayOfWeek).void%7D%0Adef%20foo(day)%0A%20%20case%20day%0A%20%20when%20Weekday%3A%3AMonday%20then%20nil%0A%20%20when%20Weekday%3A%3ATuesday%20then%20nil%0A%20%20when%20Weekday%3A%3AWednesday%20then%20nil%0A%20%20when%20Weekday%3A%3AThursday%20then%20nil%0A%20%20when%20Weekday%3A%3AFriday%20then%20nil%0A%0A%20%20when%20Weekend%3A%3ASaturday%20then%20nil%0A%20%20%23when%20Weekend%3A%3ASunday%20then%20nil%0A%20%20else%20T.absurd(day)%0A%20%20end%0Aend%0A">→
view full example on sorbet.run</a></p>
<p>Now we can use the type <code>DayOfWeek</code> for “any day of the week” or the types
<code>Weekday</code> &amp; <code>Weekend</code> in places where only one specific enum is allowed.</p>
<p>There are a couple limitations with this approach:</p>
<ol>
<li><p>Sorbet doesn’t allow calling methods on <code>T::Enum</code> when we have a value of
type <code>DayOfWeek</code>. Since it’s an interface, only the methods defined that
interface can be called (so for example <code>day_of_week.serialize</code> doesn’t type
check).</p>
<p>One way to get around this is to declare <a href="/docs/abstract">abstract methods</a> for
all of the <code>T::Enum</code> methods that we’d like to be able to call (<code>serialize</code>,
for example).</p></li>
<li><p>It’s not the case that <code>T.class_of(DayOfWeek)</code> is a valid
<code>T.class_of(T::Enum)</code>. This means that we can’t pass <code>DayOfWeek</code> (the class
object) to a method that calls <code>enum_class.values</code> on whatever enum class it
was given to list the valid values of an enum.</p></li>
</ol>
<p>The second approach addresses these two issues, at the cost of some verbosity.</p>
<h3><a class="anchor" aria-hidden="true" id="by-explicitly-converting-between-multiple-enums"></a><a href="#by-explicitly-converting-between-multiple-enums" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>By explicitly converting between multiple enums</h3>
<p>The second approach is to define multiple enums, each of which overlap values
with the other enums, and to define explicit conversion functions between the
enums:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aclass%20Module%0A%20%20include%20T%3A%3ASig%0Aend%0A%0Aclass%20DayOfWeek%20%3C%20T%3A%3AEnum%0A%20%20enums%20do%0A%20%20%20%20Monday%20%3D%20new%0A%20%20%20%20Tuesday%20%3D%20new%0A%20%20%20%20Wednesday%20%3D%20new%0A%20%20%20%20Thursday%20%3D%20new%0A%20%20%20%20Friday%20%3D%20new%0A%0A%20%20%20%20Saturday%20%3D%20new%0A%20%20%20%20Sunday%20%3D%20new%0A%20%20end%0A%0A%20%20sig%20%7Breturns(T.nilable(Weekday))%7D%0A%20%20def%20to_weekday%0A%20%20%20%20case%20self%0A%20%20%20%20when%20Monday%20then%20Weekday%3A%3AMonday%0A%20%20%20%20when%20Tuesday%20then%20Weekday%3A%3ATuesday%0A%20%20%20%20when%20Wednesday%20then%20Weekday%3A%3AWednesday%0A%20%20%20%20when%20Thursday%20then%20Weekday%3A%3AThursday%0A%20%20%20%20when%20Friday%20then%20Weekday%3A%3AFriday%0A%20%20%20%20when%20Saturday%20then%20nil%0A%20%20%20%20when%20Sunday%20then%20nil%0A%20%20%20%20else%20T.absurd(self)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20%7Breturns(T.nilable(Weekend))%7D%0A%20%20def%20to_weekend%0A%20%20%20%20case%20self%0A%20%20%20%20when%20Saturday%20then%20Weekend%3A%3ASaturday%0A%20%20%20%20when%20Sunday%20then%20Weekend%3A%3ASunday%0A%20%20%20%20when%20Monday%20then%20nil%0A%20%20%20%20when%20Tuesday%20then%20nil%0A%20%20%20%20when%20Wednesday%20then%20nil%0A%20%20%20%20when%20Thursday%20then%20nil%0A%20%20%20%20when%20Friday%20then%20nil%0A%20%20%20%20else%20T.absurd(self)%0A%20%20%20%20end%0A%20%20end%0Aend%0A%0Aclass%20Weekday%20%3C%20T%3A%3AEnum%0A%20%20enums%20do%0A%20%20%20%20Monday%20%3D%20new%0A%20%20%20%20Tuesday%20%3D%20new%0A%20%20%20%20Wednesday%20%3D%20new%0A%20%20%20%20Thursday%20%3D%20new%0A%20%20%20%20Friday%20%3D%20new%0A%20%20end%0A%0A%20%20sig%20%7Breturns(DayOfWeek)%7D%0A%20%20def%20to_day_of_week%0A%20%20%20%20case%20self%0A%20%20%20%20when%20Monday%20then%20DayOfWeek%3A%3AMonday%0A%20%20%20%20when%20Tuesday%20then%20DayOfWeek%3A%3ATuesday%0A%20%20%20%20when%20Wednesday%20then%20DayOfWeek%3A%3AWednesday%0A%20%20%20%20when%20Thursday%20then%20DayOfWeek%3A%3AThursday%0A%20%20%20%20when%20Friday%20then%20DayOfWeek%3A%3AFriday%0A%20%20%20%20else%20T.absurd(self)%0A%20%20%20%20end%0A%20%20end%0Aend%0A%0Aclass%20Weekend%20%3C%20T%3A%3AEnum%0A%20%20enums%20do%0A%20%20%20%20Saturday%20%3D%20new%0A%20%20%20%20Sunday%20%3D%20new%0A%20%20end%0A%0A%20%20sig%20%7Breturns(DayOfWeek)%7D%0A%20%20def%20to_day_of_week%0A%20%20%20%20case%20self%0A%20%20%20%20when%20Saturday%20then%20DayOfWeek%3A%3ASaturday%0A%20%20%20%20when%20Sunday%20then%20DayOfWeek%3A%3ASunday%0A%20%20%20%20else%20T.absurd(self)%0A%20%20%20%20end%0A%20%20end%0Aend%0A">→
View full example on sorbet.run</a></p>
<p>As you can see, this example is significantly more verbose, but it is an
alternative when the type safety is worth the tradeoff.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-next"></a><a href="#whats-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What’s next?</h2>
<ul>
<li><p><a href="/docs/union-types">Union types</a></p>
<p>Enums are great for defining simple sets of related constants. When the values
are not simple constants (for example, “any instance of these two classes”),
union types provide a more powerful mechanism for organizing code.</p></li>
<li><p><a href="/docs/sealed">Sealed Classes and Modules</a></p>
<p>While union types provide an ad hoc mechanism to group related types, sealed
classes and modules provide a way to establish this grouping at these types’
definitions.</p></li>
<li><p><a href="/docs/exhaustiveness">Exhaustiveness Checking</a></p>
<p>For union types, sealed classes, and enums, Sorbet has powerful exhaustiveness
checking that can statically catch when certain cases have not been handled.</p></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/tstruct"><span class="arrow-prev">← </span><span>T::Struct</span></a><a class="docs-next button" href="/docs/untyped"><span>T.untyped</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#exhaustiveness">Exhaustiveness</a></li><li><a href="#enum-values-in-types">Enum values in types</a></li><li><a href="#converting-enums-to-other-types">Converting enums to other types</a></li><li><a href="#converting-from-other-types-to-enums">Converting from other types to enums</a></li><li><a href="#listing-the-values-of-an-enum">Listing the values of an enum</a></li><li><a href="#attaching-metadata-to-an-enum">Attaching metadata to an enum</a></li><li><a href="#defining-one-enum-as-a-subset-of-another-enum">Defining one enum as a subset of another enum</a><ul class="toc-headings"><li><a href="#by-using-a-sealed-module">By using a sealed module</a></li><li><a href="#by-explicitly-converting-between-multiple-enums">By explicitly converting between multiple enums</a></li></ul></li><li><a href="#whats-next">What's next?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>