<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Type Aliases · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="```ruby"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Type Aliases · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="```ruby"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/type-aliases.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Type Aliases</h1></header><article><div><span><pre><code class="hljs css language-ruby">Alias = T.type_alias {Type}
</code></pre>
<p>This creates a type alias of <code>Type</code> called <code>Alias</code>. In the context of Sorbet,
the type alias has exactly the same behavior as the original type and can be
used anywhere the original type can be used. The converse is also true.</p>
<p>Note that the type alias will not show up in error messages.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

Int = T.type_alias {Integer}
Str = T.type_alias {String}

sig {params(<span class="hljs-symbol">x:</span> Int).returns(Str)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  T.reveal_type(x) <span class="hljs-comment"># Revealed type: Integer</span>
  x.to_s
<span class="hljs-keyword">end</span>

a = T.let(<span class="hljs-number">3</span>, Integer)
foo(a)
b = T.let(<span class="hljs-number">3</span>, Int)
foo(b)

c = foo(<span class="hljs-number">3</span>)
T.reveal_type(c) <span class="hljs-comment"># Revealed type: String</span>
</code></pre>
<p>When creating a type alias from another type alias, you <a href="https://sorbet.org/docs/error-reference#5034">must use <code>T.type_alias</code>
again</a>:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = T.type_alias {A}
</code></pre>
<p>For simple use cases, type aliases are nearly identical to just making a new
constant:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

A = T.type_alias {Integer}
sig {returns(A)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-number">3</span>; <span class="hljs-keyword">end</span>

B = Integer
sig {returns(B)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-number">3</span>; <span class="hljs-keyword">end</span>
</code></pre>
<p>However, when the type is more complex, you must use type aliases:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

A = T.type_alias {T.any(Integer, String)}
sig {returns(A)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-number">3</span>; <span class="hljs-keyword">end</span>

B = T.any(Integer, String)
sig {returns(B)} <span class="hljs-comment"># error: Constant B is not a class or type alias</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-number">3</span>; <span class="hljs-keyword">end</span>
</code></pre>
<p>Note that because type aliases are a Sorbet construct, they cannot be used in
certain runtime contexts. For instance, it is not possible to match an
expression against a type alias in a <code>case</code> expression.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-keyword">end</span>

AB = T.type_alias {T.any(A, B)}
sig {params(<span class="hljs-symbol">x:</span> T.any(AB, C)).returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">invalid</span><span class="hljs-params">(x)</span></span> <span class="hljs-comment"># error: Returning value that does not conform to method result type</span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> AB <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-comment"># &lt;- this line is problematic</span>
  <span class="hljs-keyword">when</span> C <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We could refactor this example to use <code>A, B</code> in the <code>when</code> and <code>AB</code> in the
<code>sig</code>. However, this introduces coupling between the definition of <code>AB</code> and our
method. If we ever updated the definition of <code>AB</code>, we would need to update the
definition of our method as well.</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">x:</span> T.any(AB, C)).returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A, B <span class="hljs-keyword">then</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">when</span> C <span class="hljs-keyword">then</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="what-about-type-aliases-for-method-signatures"></a><a href="#what-about-type-aliases-for-method-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What about type aliases for method signatures?</h2>
<p>Sometimes a question arises like, “Is there a way to factor an entire method
signature into a type alias, not just types for individual arguments?”</p>
<p>No, there is not. This is mostly for simplicity of implementation within Sorbet.</p>
<p>Two workarounds are:</p>
<ol>
<li>Define type aliases for all argument and return types of the methods in
question.</li>
<li>Factor shared arguments into a typed data structure (perhaps using
<a href="/docs/tstruct">T::Struct</a>), and update the methods in question to take that structure.</li>
</ol>
<p>Note that types for lambdas and procs can be written in type aliases using
<a href="/docs/procs">proc types</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="what-about-recursive-type-aliases"></a><a href="#what-about-recursive-type-aliases" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What about recursive type aliases?</h2>
<p>Some languages have recursive type aliases. For example, TypeScript allows
writing type aliases like this one which vaguely describes the type of all JSON
documents (example uses TypeScript syntax):</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">type</span> <span class="hljs-built_in">JSON</span> = <span class="hljs-literal">null</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">JSON</span>[] | {[arg: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">JSON</span>};
</code></pre>
<p>Sorbet does not support recursive type aliases. To have types that reference
themselves, use <a href="/docs/class-types">class types</a>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelfReferential</span></span>
  extend T::Sig

  sig {returns(T.nilable(SelfReferential))}
  <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:val</span>

  sig {params(<span class="hljs-symbol">val:</span> T.nilable(SelfReferential)).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(val)</span></span>; @val = val; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Unfortunately for the case of typing JSON, this generally leads to more
verbosity than in other languages, but can still accomplish something similar:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0A%0Amodule%20MyJSON%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20sealed!%0A%0A%20%20sig%20%7Bparams%28json%3A%20T.untyped%29.returns%28MyJSON%29%7D%0A%20%20def%20self.from_untyped%28json%29%0A%20%20%20%20case%20json%0A%20%20%20%20when%20nil%20then%20JSONNull.instance%0A%20%20%20%20when%20String%20then%20JSONString.new%28val%3A%20json%29%0A%20%20%20%20when%20Numeric%20then%20JSONNumber.new%28val%3A%20json%29%0A%20%20%20%20when%20Array%20then%20JSONArray.new%28val%3A%20json.map%20%7B%7Cj%7C%20from_untyped%28j%29%7D%29%0A%20%20%20%20when%20Hash%20then%20JSONObject.new%28val%3A%20json.transform_values%20%7B%7Cj%7C%20from_untyped%28j%29%7D%29%0A%20%20%20%20else%20raise%28ArgumentError.new%28%22malformed%20json%22%29%29%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20class%20JSONNull%0A%20%20%20%20include%20MyJSON%0A%20%20%20%20include%20Singleton%0A%20%20end%0A%0A%20%20class%20JSONString%20%3C%20T%3A%3AStruct%0A%20%20%20%20include%20MyJSON%0A%20%20%20%20prop%20%3Aval%2C%20String%0A%20%20end%0A%0A%20%20class%20JSONNumber%20%3C%20T%3A%3AStruct%0A%20%20%20%20include%20MyJSON%0A%20%20%20%20prop%20%3Aval%2C%20Numeric%0A%20%20end%0A%0A%20%20class%20JSONArray%20%3C%20T%3A%3AStruct%0A%20%20%20%20include%20MyJSON%0A%20%20%20%20prop%20%3Aval%2C%20T%3A%3AArray%5BMyJSON%5D%0A%20%20end%0A%0A%20%20class%20JSONObject%20%3C%20T%3A%3AStruct%0A%20%20%20%20include%20MyJSON%0A%20%20%20%20prop%20%3Aval%2C%20T%3A%3AHash%5BString%2C%20MyJSON%5D%0A%20%20end%0Aend">→ Full example on sorbet.run</a></p>
<p>For the specific example of typing JSON, note that most Sorbet users tend to
just use <code>T::Hash[String, T.untyped]</code> or <code>T.untyped</code>. Serializing and
deserializing JSON is usually handled better by purpose-built serialization
libraries. The type of “all JSON documents” is usually unnaturally wide—it’s
better to have an explicit step which converts the loosely JSON data structure
into a more structured internal representation.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/flow-sensitive"><span class="arrow-prev">← </span><span>Flow-Sensitivity (is_a?, nil?)</span></a><a class="docs-next button" href="/docs/exhaustiveness"><span>Exhaustiveness (T.absurd)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-about-type-aliases-for-method-signatures">What about type aliases for method signatures?</a></li><li><a href="#what-about-recursive-type-aliases">What about recursive type aliases?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>