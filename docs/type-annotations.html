<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Type Annotations · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Sorbet provides the most value when it has a wealth of programmer-supplied"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Type Annotations · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="Sorbet provides the most value when it has a wealth of programmer-supplied"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">Signatures</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/type-annotations">Type Annotations</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">Type Assertions</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow Sensitivity</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">Type Aliases</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/type-annotations.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Type Annotations</h1></header><article><div><span><p>Sorbet provides the most value when it has a wealth of programmer-supplied
static types. However, because Sorbet implements a
<a href="/docs/gradual">gradual type system</a>, it treats most definitions without explicit
annotations as <a href="/docs/untyped">untyped</a>. This means that Sorbet can only use static
types for methods, constants, instance variables, and class variables if they
are accompanied with explicit static types.</p>
<p>The exceptions to the above list are that Sorbet does not need type annotations
for local variables or in some simple cases for instance variables. In the
absence of a type annotation, Sorbet will infer the type of a local variable
based on how the variable is initialized. It is still possible to provide type
annotations in these instances.</p>
<p>Type annotations for methods are provided using a <code>sig</code> before the method
definition. Method type annotations are
<a href="/docs/sigs">described in great detail on the Method Signatures</a>. Other type
annotations are provided using the <code>T.let</code> <a href="/docs/type-assertions">type assertion</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="when-are-type-annotations-optional"></a><a href="#when-are-type-annotations-optional" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When Are Type Annotations Optional?</h2>
<p>Sorbet does not need type annotations for local variables, as it can infer the
type of the local variable based on how it is initialized. For example, in the
following program, Sorbet can tell <code>x</code> is an <code>Integer</code> based on the fact that it
is initialized with an expression that evaluates to an <code>Integer</code>:</p>
<pre><code class="hljs css language-ruby">x = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>
</code></pre>
<p>You may still provide a wider type annotation if you would like. This can
occasionally be helpful if you want the type of a variable to be broader than
Sorbet’s inferred type, such as in situations where you are changing the value
of a variable in a loop to something that is broader than the expression that
you use to initialize the variable:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># without this T.let, x would have the inferred type NilClass</span>
x = T.let(<span class="hljs-literal">nil</span>, T.nilable(Integer))
(<span class="hljs-number">0</span>..<span class="hljs-number">10</span>).each <span class="hljs-keyword">do</span> <span class="hljs-params">|n|</span>
  x = n <span class="hljs-keyword">if</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sorbet can also infer the types of instance variables in some limited
situations, specifically when the instance variable is initialized with the
value of a parameter of the constructor:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObj</span></span>
  sig {params(<span class="hljs-symbol">x:</span> Integer).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(x)</span></span>
    @y = x  <span class="hljs-comment"># y has the inferred type Integer</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>For more details on why Sorbet can only infer the types of instance variables in
relatively narrow situations, see the section below about the
<a href="#limitations-on-instance-variable-inference">limitations on instance variable inference</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="annotating-constants"></a><a href="#annotating-constants" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating constants</h2>
<p>Sorbet does not, by default, infer the types of constants, but they can be
specified using <code>T.let</code>:</p>
<pre><code class="hljs css language-ruby">NAMES = T.let([<span class="hljs-string">"Nelson"</span>, <span class="hljs-string">"Dmitry"</span>, <span class="hljs-string">"Paul"</span>], T::Array[String])
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="declaring-class-and-instance-variables"></a><a href="#declaring-class-and-instance-variables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Declaring class and instance variables</h2>
<p>To declare the static type of an instance variable, we can use <code>T.let</code> in a
class’s constructor:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObj</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @foo = T.let(<span class="hljs-number">0</span>, Integer)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We can also declare class variables and instance variables on a singleton class
using <code>T.let</code> at the top-level of a class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HasVariables</span></span>
  <span class="hljs-comment"># Class variable</span>
  @@llamas = T.let([], T::Array[Llama])

  <span class="hljs-comment"># Instance variable on the singleton class</span>
  @alpaca_count = T.let(<span class="hljs-number">0</span>, Integer)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sorbet requires that instance and class variables are defined in these specific
places to guarantee that they’re initialized. But sometimes requiring that these
variables be declared in specific places is too restrictive. Sorbet allows an
instance variable to be declared <strong>anywhere</strong> so long as the type is at least
nilable:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-comment"># Does NOT have to be declared in `initialize`, because it's nilable:</span>
    @x = T.let(<span class="hljs-number">0</span>, T.nilable(Integer))
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span></span>
    <span class="hljs-comment"># Also works for `self.` methods:</span>
    @y = T.let(<span class="hljs-string">''</span>, T.nilable(String))
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s common to use this technique to add type annotations for instance variables
in functions that memoize their results by lazily initializing instance
variables:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
  sig {returns(String)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">current_user</span></span>
    <span class="hljs-keyword">unless</span> <span class="hljs-keyword">defined</span>?(@user)
      @user = T.let(ENV.fetch(<span class="hljs-string">'USER'</span>), T.nilable(String))
    <span class="hljs-keyword">end</span>
    T.must(@user)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="limitations-on-instance-variable-inference"></a><a href="#limitations-on-instance-variable-inference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Limitations on instance variable inference</h2>
<p>A current shortcoming of Sorbet is that in many cases it cannot reuse static
type knowledge in order to automatically determine the type of an instance or
class variable. In the following example, Sorbet will naturally understand that
<code>@x</code> is of type <code>Integer</code>, but it cannot determine the static type of <code>@y</code>
without a <code>T.let</code> and therefore treats it as <code>T.untyped</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span> Integer).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(x, y)</span></span>
    @x = x
    @y = y + <span class="hljs-number">0</span>

    T.reveal_type(@x)  <span class="hljs-comment"># Integer</span>
    T.reveal_type(@y)  <span class="hljs-comment"># T.untyped</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sorbet can only infer the types of instance variables in a relatively specific
context: in particular, only when that instance variable is initialized to the
exact value of a parameter to the constructor in the body of the constructor. In
other cases, you will need to use <code>T.let</code> to explicitly give the types of
instance variables.</p>
<blockquote>
<p><strong>Note</strong>: This particular limitation is because of how Sorbet performs
typechecking: it needs to know the types of instance variables <em>before</em> it
typechecks method definitions, but even a simple expression like <code>y + 0</code> will
require a typechecking pass to determine what its resulting type is, which
means Sorbet won’t be able to tell what type to infer for an instance variable
until <em>after</em> it has already started typechecking the method where instance
variables are defined. Sorbet resolves this cyclical dependency by either
using types that you have explicitly defined with <code>T.let</code>, or by relying on
simple code patterns like the one described above.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="type-annotations-and-strictness-levels"></a><a href="#type-annotations-and-strictness-levels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type annotations and strictness levels</h2>
<p>Sorbet allows the programmer to opt-in to greater levels of static type rigor.
At lower <a href="/docs/static">strictness modes</a>, Sorbet allows definitions to be untyped,
but at <code># typed: strict</code>, Sorbet requires explicit type annotations on any
definitions where it would have assumed <code>T.untyped</code> without an annotation
before. Specifically, in a <code># typed: strict</code> file it’s an error to omit type
annotations for:</p>
<ul>
<li>methods</li>
<li>instance variables</li>
<li>class variables</li>
<li>constants</li>
</ul>
<p>It may seem counterintuitive that Sorbet does <em>not</em> require type annotations in
a file marked <code># typed: true</code>, but this is an intentional part of Sorbet’s
implementation of <a href="/docs/gradual">gradual typing</a>. In the <code># typed: true</code>
strictness level, unannotated methods, instance variables, and constants are
assumed to be <code>T.untyped</code>. This allows a programmer to write untyped or
partially-typed definitions while still benefiting from type checking when
static type information is present.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/sigs"><span class="arrow-prev">← </span><span>Signatures</span></a><a class="docs-next button" href="/docs/type-assertions"><span>Type Assertions</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#when-are-type-annotations-optional">When Are Type Annotations Optional?</a></li><li><a href="#annotating-constants">Annotating constants</a></li><li><a href="#declaring-class-and-instance-variables">Declaring class and instance variables</a></li><li><a href="#limitations-on-instance-variable-inference">Limitations on instance variable inference</a></li><li><a href="#type-annotations-and-strictness-levels">Type annotations and strictness levels</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>